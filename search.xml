<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[那年学过的Web前端笔记]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[XML XML中的注意事项: HTML CSS JavaScript 控制台对象console 普通日志输出: console.log(文本); 错误信息输出:console.error(文本); 提示信息输出:console.info(文本); 警告信息输出:console.warn(文本); debug信息输出:console.debug(文本); Math类 随机数: Math.random(); 产生一个0-1的随机浮点型数字 四舍五入:Math.round(x); 将浮点数字 , 四舍五入为整型数字 Number 转换数字: var 整型数字 = parseInt(字符串); var 整型|浮点型 = new Number(字符串); 截取数字: number.toFixed(小数点后保留位数); 正则表达式步骤: 1. 创建正则表达式对象 var 对象名 = /正则表达式字符串/g; 2. 通过正则表达式对象的test方法, 验证数据是否匹配正则 var flag = 正则对象.test(要验证的数据); 返回值为boolean类型 案例: function testx(val){ var reg = /^(13[0-9]|14[4789]|15[012356789]|17[0-9]|18[0-9])[0-9]{8}$/g; var flag = reg.test(val); if(flag){ alert(&quot;用户名可用&quot;); }else{ alert(&quot;很遗憾, 用户名不可用&quot;); } } URI编码 将文字进行uri编码:var uriCode = encodeURI(&quot;文字&quot;); 将uri编码文字 进行解码var text = decodeURI(uriCode); HTML DOM对象通过文档对象(document) , 获取元素对象四种方式: 通过元素的id属性, 获取一个元素对象 var element = document.getElementById(&quot;id值&quot;); 通过元素的标签名称, 后获取一个元素对象数组 var elements = document.getElementsByTagName(&quot;标签名&quot;); 通过元素的name属性值, 获取一个元素对象数组 var elements = document.getElementsByName(&quot;name属性值&quot;); 通过元素的class属性值 , 获取一个元素对象数组 var elements = document.getElementsByClassName(&quot;class属性值&quot;); 元素属性值的操作 属性值获取: var value = 元素对象.属性名; 属性值设置: 元素对象.属性名 = 值; 特殊的属性操作: class属性值的设置与获取: 获取属性值: var classx = 元素对象.className; 设置属性值: 元素对象.className = class值; 设置与获取元素的文本内容 获取文本内容: var text = 元素对象.innerHTML; 设置文本内容: 元素对象.innerHTML = 文本内容; 节点对象查找元素节点 一次得到一个节点: 元素对象.parentNode: 获取父元素 元素对象.firstChild: 获取第一个子元素 元素对象.lastChild : 获取最后一个子元素 一次得到一组节点: 元素对象.childNodes: 获取所有子元素 (返回值为元素数组) 节点分类元素节点分为: 文本节点 : 通过层次获取节点时, 会得到文本节点 , 比如: 通过父元素 获取所有子元素 , 就是包含文本节点 + 元素节点的 属性节点 : 通过元素调用attributes属性, 得到所有属性对象 ! 所有的节点对象, 都拥有如下三个特殊的属性: - nodeName : 用于获取节点名称 - nodeValue : 用于获取节点值 (元素节点为null , 文本节点为文本内容, 属性节点返回属性值) - nodeType : 获取元素类型: 1表示元素节点 2表示属性节点 3表示文本节点 节点的操作 创建节点var element = document.createElement(&quot;节点名称&quot;); 插入节点通过父元素, 追加子元素 父元素对象.appendChild(子元素对象); 通过父元素 ,并提供一个参考子元素, 插入参考子元素之前 ! 父元素对象.insertBefore(子元素对象,参考元素); 如果不存在参考元素, 则效果为追加 ! 删除节点父元素.removeChild(子节点对象); window对象 打开新窗口 格式: var newWindow = window.open(url,[name],[config],[specs]); url : 新打开的窗口 加载的资源地址 name : 新窗口的唯一标识, 不是展示出的窗口标题 ,类似窗口id 用来操作此窗口 , 相同的窗口名称 无法同时展示两个 config : 窗口的配置参数 使用字符串来描述窗口配置, 字符串由多个键值对组成, 键与值之间使用等号连接, 多个键值之间使用逗号分割 . - 常用配置参数: - height : 窗口高度 px - width : 窗口宽度 px - left : 新的窗口距离 屏幕左上角的横向偏移位置 - top : 新的窗口距离 屏幕左上角的垂直偏移位置 - 不常用配置参数:(多数浏览器不支持) 都是boolean类型参数 , 可以指定的值为:yes|no|1|0 - location : 新窗口是否显示地址栏 - menubar : 是否显示菜单栏 - resizable : 窗口是否可调整大小 - scrollbars : 是否显示滚动条 - titlebar : 是否显示标题栏 - tollbar : 是否显示工具栏 specs : 是否允许加载历史文件 true表示允许 关闭窗口的函数: window.close(); 定时器一次性定时器格式: setTimeout(“执行的语句”,延迟毫秒); 周期性定时器 开启周期性定时器 格式: var x = setInterval(&quot;执行的语句&quot;,周期时长毫秒); 返回值:周期性定时器对象 关闭周期性定时器 格式: clearInterval(周期性定时器对象); 屏幕信息的获取(window子对象 screen) screen : 用于获取屏幕信息的对象 获取屏幕宽度var width = screen.width; 获取屏幕高度var height = screen.height; 获取屏幕可用宽度var width = screen.availWidth; 获取屏幕可用高度var height = screen.availHeight; window子对象 historyhistory: 函数: back():浏览器后退一页 forward():浏览器前进一页 go(数字) , 正数表示前进指定页数, 负数表示后退指定页数 indow子对象locationlocation: 属性: href:表示当前浏览器 加载的网址地址 ! 函数: assign(url) :跳转页面到指定url replace(url):替换当前页面到指定url (替换不等于跳转, 被替换掉的页面, 无法通过后退打开) reload(): 刷新网页 这个知识点, 重要的地方是, 我们可以通过JS的运算, 得到一些数据, 然后通过网址 提交给服务器 ! 事件事件：指 HTML 对象在状态改变、操作鼠标或键盘时触发的动作 鼠标事件 键盘事件 状态改变事件 event 对象 事件触发后将会产生一个 event 对象 -在任何的事件触发的代码中, 都可以通过event对象 来操作 常用属性: - clientX : 鼠标事件触发时的坐标点X - clientY : 鼠标事件触发时的坐标点Y - keyCode : 键盘事件 , 触发时的键盘按键的code值 JQuery Jquery的onload实现$(function(){ //当网页加载完毕时执行 }); 选择器基本选择器 id选择器 格式: var $obj = $(&quot;#id值&quot;); 类选择器 格式: var $obj = $(&quot;.class值&quot;); 标签名称选择器 格式: var $obj = $(&quot;标签名称&quot;); 层级选择器 子选择器 *格式: var $obj =$(&quot;父元素选择器&gt;子选择器&quot;); 后代选择器 *格式: var $obj =$(&quot;父元素选择器 后代选择器&quot;); 后一个兄弟选择器格式: var $obj =$(&quot;选择器+兄弟选择器&quot;); 后所有兄弟选择器格式: var $obj =$(&quot;选择器~兄弟选择器&quot;); 筛选选择器: first:匹配第一个元素: last:匹配最后一个元素: not:过滤not条件:$(“div:not(.class)”);: even:匹配下标偶数: odd:匹配下标奇数: eq:选择指定索引值 :$(“div:eq(1)”): gt:匹配索引值大于x的:$(“div:gt(5)”): lt:匹配索引值小于x的:$(“div:lt(5)”) 示例: $(function(){ $(“p:first”).css({“color”:”#090”}); $(“p:not(#a)”).css({“font-size”:”10px”}); $(“p:gt(2)”).css({“font-size”:”16px”}); }); jQuery常用函数获取和修改元素文本内容在原生JS的操作中, 我们使用元素对象的inenrHTML属性 来修改元素的文本内容. 在Jquery中, 提供了两个方法, 可以用来获取/设置文本内容 1. $obj.html(文本) | var 文本 = $obj.html(); 获取元素文档内容 2. var 获取文本 = $obj.text() 获取元素文本内容 html函数与text函数区别: 使用html函数获取文本时, 会获取到子标签 使用text函数获取文本时, 只能获取到不包含标签的文本内容 获取和修改元素的属性值在JS代码中, 我们可以通过 dom对象.属性名 来操作一个元素的属性 !在Jquery中可以通过attr函数 操作所有的属性:获取属性值: var value = $obj.attr(&quot;属性名&quot;); 设置属性值: $obj.attr(&quot;属性名&quot;,&quot;属性值&quot;); 删除属性值: $obj.removeAttr(&quot;属性名&quot;); 修改元素样式css函数 两个方法的重载: 用于一次指定多个样式 格式: $obj.css(json格式的样式对象); 用于一次指定一个样式 格式: $obj.css(“样式key”,”样式值”); 案例: $(&quot;img&quot;).css(&quot;box-shadow&quot;,&quot;3px 3px 3px 3px #aaa&quot;); calss属性值的设置与获取添加class属性值 $obj.addClass(“值”);删除class属性值 $obj.removeClass(“值”);替换class属性值 $obj.toggleClass(“值”); 显示和隐藏函数 基本效果显示: $obj.show(); 隐藏: $obj.hide(); 切换: $obj.toggle(); 左上折叠效果显示: $obj.show(time毫秒); 隐藏: $obj.hide(time毫秒); 切换: $obj.toggle(time毫秒); 上下折叠效果显示: $obj.slideDown(time毫秒); 隐藏: $obj.slideUp(time毫秒); 切换: $obj.slideToggle(time毫秒); 如果使用到图片上, 元素必须存在确定的宽度 ,才可以实现上下折叠 淡入淡出效果显示: $obj.fadeIn(time毫秒); 隐藏: $obj.fadeOut(time毫秒); 自定义动画$obj.animate(参数1,参数2,[参数3]); 参数1. JSON对象, 描述动画执行结果的样式 参数2. 从当前样式, 过渡到参数1样式的 毫秒时间 参数3. 可选参数, function类型 , 动画执行完毕的监听函数 (当动画执行完毕, 自动执行此函数) JQuery事件绑定和解绑事件 绑定事件: $obj.bind(&quot;事件类型&quot;,处理函数); 解绑事件:$obj.unbind(&quot;事件类型&quot;); 模拟事件触发: $obj.trigger(&quot;事件类型&quot;); 事件函数$obj.click(fn)// 当点击 $obj.dblclick(fn)//当双击 $obj.blur(fn)//当失去焦点 $obj.focus(fn)//当获取焦点 $obj.change(fn)//当状态改变 ,常用于下拉选框 $obj.keydown(fn)//当键盘按下 $obj.keyup(fn)//当键盘弹起 $obj.mouseover(fn)//当鼠标指针位于元素上 $obj.mouseout(fn)//当鼠标指针从元素上滑出 $obj.submit(fn)//表单提交事件, 等同于form元素的onsubmit事件, return false 可以阻止表单提交 ***** $obj.load(fn)//当元素加载完毕 $obj.unload(fn)//当元素销毁 组合事件hover(over,out); 参数1. function类型 , 鼠标移入时触发的事件代码 参数2. function类型 , 鼠标移出时触发的事件代码 动态绑定事件格式: 注意: 添加动态绑定事件的未来元素, 必须有一个已经存在的父元素 ! $父元素对象.on(&quot;事件类型&quot;,&quot;寻找子元素的选择器&quot;,func处理函数); 文档函数 创建元素var $obj = $(&quot;html元素&quot;); 例如: 创建一个按钮: var $obj = $(&apos;&lt;input type=&quot;button&quot; value=&quot;示例按钮&quot;&gt;&apos;); 将Jquery元素对象, 添加到网页中 通过父元素 向父元素内部追加格式: $父元素.append($新元素); 通过父元素 向父元素内部前置格式: $父元素.prepend($新元素); 通过一个元素, 向这个元素的后面添加格式: $obj.after($新元素); 通过一个元素, 想这个元素的前面添加格式: $obj.before($新元素); 从网页中 删除一个节点格式: $要删除的元素.remove(); 清空一个节点格式: $要清空的元素.empty(); 克隆一个节点 var $新对象 = $原对象.clone(); //克隆元素, 不克隆元素事件; var $新对象 = $原对象.clone(true); //克隆元素, 克隆元素事件; 文档查找children(选择器) 查找子元素 next() 查找后面的兄弟元素 prev() 查找前面的兄弟元素 siblings() 查找兄弟元素 find(选择器) 查找子元素及后代元素 parent() 查找父元素 parents(selector) 查找祖先元素 工具函数$.each 遍历 可应用于 遍历对象 , 遍历数组 遍历对象遍历Jquery对象, 得到其中的每一个dom对象 格式: $obj.each(function(){ //在这里this 表示每次遍历的dom对象 }); 遍历数组遍历一个JS数组, 得到每一个下标的数据 $.each(数组,function(i,value){ //i表示遍历时的数据下标 //value表示遍历时的数据 }); 去除数组中重复元素 (此函数直接操作原数组, 无返回值) 格式: $.unique(数组); 合并数组: 将两个数组合并 ( 将第二个数组中的所有内容,追加到第一个数组中) 格式: $.merge(数组1,数组2); 去除字符串中的前后空格: (不会对原字符串产生影响, 返回值为去除空格的文本) 格式: $.trim(字符串); HTML5获取用户地理位置步骤:判断浏览器是否支持获取,支持则获取也可以使用脚本工具进行获取 WEB存储浏览器存储数据的两个对象: localStorage没有时间限制的数据存储方式 !在用户未清除浏览器数据时 , 数据一直存在 ! sessionStorage当览器关闭后, 会话结束, 数据清除! 注意: 这两个对象 ,在操作上, 只是名称不同, api完全一致 ! 在使用web存储之前, 应验证浏览器是否支持web存储(支持的浏览器: IE8+ 和 其他浏览器) if(typeof(Storage) !== &quot;undefined&quot;){ //支持web存储 }else{ //不支持web存储 } 常用函数: 保存数据: storage.setItem(key,value); 获取数据: var value = storage.getItem(key); 删除单个数据:storage.removeItem(key); 删除所有数据:storage.clear(); 获取指定索引下的key: var key = storage.key(index); 获取键值对的数量: var length = storage.length;]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的web后端笔记]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84web%E5%90%8E%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Http协议 B/S Servlet Servlet编写案例: public class Servlet1 extends HttpServlet { protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter pw = response.getWriter(); pw.append(&quot;&lt;h1&gt;我们的第一个servlet&lt;/h1&gt;&quot;); } } xml中配置Servlet步骤: 1. 将Servlet 配置到web.xml中, 并起别名 &lt;servlet&gt; &lt;servlet-name&gt;别名&lt;/servlet-name&gt; &lt;servlet-class&gt;类的全称(包名.类名)&lt;/servlet-class&gt; &lt;/servlet&gt; 2. 使用Servlet别名, 映射一个或多个网址 &lt;servlet-mapping&gt; &lt;servlet-name&gt;别名&lt;/servlet-name&gt; &lt;url-pattern&gt;/映射地址&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ..... &lt;servlet-mapping&gt; &lt;servlet-name&gt;别名&lt;/servlet-name&gt; &lt;url-pattern&gt;/映射地址2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 映射完毕后, 访问此servlet的方式: http://ip地址:端口号/项目名/映射地址 案例: &lt;servlet&gt; &lt;servlet-name&gt;s1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.xdl.demo.Servlet1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;s1&lt;/servlet-name&gt; &lt;url-pattern&gt;/666.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet生命周期生命周期 在Servlet中, 存在三个方法的体现: init方法 : 当此方法被调用时, 表示对象已创建, 且初始化完成! 我们常在此方法中初始化 一些资源 ! service方法 : 当被调用时, 表示来了一个客户端的请求, 此方法每次都执行在一个新的线程中 ! destroy方法: 当此方法被调用时,表示Servlet即将被销毁 ! 我们常在此方法中 释放资源 ! 乱码问题请求时乱码方式一:可适用于所有问题 引起的乱码 原理: 将乱码的文字, 重新变为字节数组, 再按照我们支持的编码重新组装 ! 步骤1. 将接收到的文字, 按照ISO-8859-1编码打碎成字节数组 byte[] b = 乱码文字.getBytes(&quot;ISO-8859-1&quot;); 步骤2. 将打碎后的字节数组, 按照UTF-8组装 String text = new String(b,&quot;UTF-8&quot;); 简化: String text = new String(乱码文字.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); 方式二: 只能解决POST乱码问题, 用于在获取数据之前, 设置请求体的编码格式 request.setCharacterEncoding(&quot;UTF-8&quot;); 响应时乱码在处理响应时数据时, 无论时get/post请求, 方式都一致 ! 一定要在获取输出流之前!方式一: 设置网页内容类型 , 并设置网页编码 , 不建议使用 response.setContentType(&quot;text/html;charset=utf-8&quot;); 方式二: 设置文字编码为UTF-8 response.setCharacterEncoding(&quot;UTF-8&quot;); 请求转发和重定向 Cookie和Session Cookie常用方法: 如何将Cookie设置到响应的消息头: response.addCookie(Cookie cookie); 如何从请求的消息头中获取Cookie: 因为服务器可以给浏览器多个Cookie, 所以得到的是一个Cookie数组 Cookie[] cookies = request.getCookies(); Session常用方法:(session是JSP四大域对象之一) 设置属性: setAttribute(String key,Object value); 获取属性: Object value = getAttribute(String key); 删除属性: removeAttribute(String key); 销毁Session: invalidate(); 设置Session存活时长:方式一: 修改所有的session默认时长 修改tomcat目录下的conf文件夹下的 web.xml &lt;session-config&gt; &lt;session-timeout&gt;数字类型: 分钟&lt;/session-timeout&gt; &lt;/session-config&gt; 方式二:修改单个session存活时长: 使用session对象, 调用setMaxInactiveInterval(int 秒); JSP JSP即是Java Server Pages的简称 JSP三大指令page指令用来快速的描述JSP页面的信息, 用来对JSP页面进行配置:常用属性: &lt;%@page language=“script language”|-- 语言 ,一般为java extends=“className” |--可以指定JSP在生成Java文件时, 文件所继承的Java类 *import=“importList” |--导包列表 ,可以在参数中导入多个包, 多个包之间使用逗号隔开 buffer=“none|kb size”| --none:不缓冲，默认8k session=“true|false” | --是否可以使用session，默认true autoFlush=“true|false” --缓冲器是否自动清除，默认true isThreadSafe=“true|false”|--当前JSP代码执行区是否为线程安全的 *errorPage=“errorPageUrl” |--指定产生错误后, 处理错误的页面 *isErrorPage=“true|false” |--表示当前页面是否为处理错误的页面 contentType=“contentTyepInfo”|--描述网页的内容类型 和 编码格式 %&gt; 导包案例: &lt;%@page import=&quot;java.util.HashMap,java.util.ArrayList&quot; %&gt; 错误页面处理: 在产生错误的页面中加入page指令, errorPage属性中指定错误处理页面 在错误处理的jsp文件中, 指定isErrorPage为true , 可以直接操作一个叫做exception的对象 在操作exception时, 注意有可能为null(当用户直接访问错误页面时) 处理项目中的错误码使用上述的page指令, 无法处理404错误, 只有当程序出现BUG时, 才可以处理异常 !想要处理404异常, 需要告知tomcat , 当在本项目中用户访问出现404以后, 跳转到指定页面: 在项目的web.xml中添加如下节点: &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; include指令用来在一个JSP文件中, 引入另一个JSP程序 或 HTML文件 !格式: &lt;%@include file=&quot;文件路径&quot; %&gt; JSP文件 在引擎转换时, 会将引入的文件代码复制粘贴到include指令的位置, 然后统一进行转换与编译操作(转换为一个Java文件)! include动作用于在一个JSP文件中, 引入另一个JSP程序 或 HTML文件 !格式: &lt;jsp:include page=&quot;文件地址&quot; flush=&quot;true&quot;/&gt; include动作引入的JSP文件 , 在转换为.java的时候, 是单独转换的 ,只有在代码执行到include动作时, 才会编译被引入的文件, 动态载入! taglib指令JSP内置对象 隐含对象 类型 作用 out JSPWriter 用来向客户端进行字符的响应 request HttpServletRequest 请求对象, 包含Http协议中请求数据 response HttpServletResponse 响应对象 session HttpSession 会话对象, 用来在一次会话中对单个用户 进行数据的共享与会话的跟踪 application ServletContext Servlet上下文 , 每个应用在启动时会创建且只创建一个对象, 在应用关闭时,对象被释放. 用来在当前项目中Servlet之间进行数据的共享与通信 pageContext PageContext 页面的上下文, 用于在当前页面进行数据的共享 , 在设计9大内置对象时, 将所有其他内置对象封装在了PageContext中 config ServletConfig 配置对象 page Object 当前页面本身 exception Throwable 当page指令中 isErrorPage为true时 才会产生此对象 , 用于收集其他页面产生的异常信息 四大域对象 EL和JSTL Filter&amp;Listener组件在web.xml文件中配置Filter组件和Servlet配置基本一致不使用注解在web.xml中配置Listener &lt;listener &gt; &lt;listener-class&gt;包名 + 类名&lt;/listener-class&gt; &lt;/listener&gt; AJAX AJAX优点作用:(1)异步请求和响应处理(2)页面局部刷新处理优点: 减少页面整体刷新，提升用户体验(局部刷新) 减少交互的数据量，提升程序性能 以异步模式处理请求，较少用户操作等待时间，增 强了用户的操作连续性(异步交互) AJAX技术应用步骤 创建XMLHttpRequest对象 调用open方法，创建请求 设定onreadystatechange事件函数，用于 响应处理 调用send方法发送请求 // 发送请求之前的准备 对象.open(请求方式,请求路径,是否异步) 如 xhr.open(&apos;get&apos;,&apos;getDate.do&apos;,true); // 注册请求处理函数 xhr.onreadystatechange=function(){ // 请求响应完成 并且 http 状态 是 200 if(xhr.readyState == 4 &amp;&amp; xhr.status==200){ // 获取请求响应的数据 var text = xhr.responseText; } }; // 发送请求 xhr.send(null); AJAX+Json应用Json JSON （JavaScript Object Notation）是 JavaScript语言中的一种对象类型。 JSON的好处是易于阅读和JavaScript解析 当客户端和服务器端交互大量数据时，使用JSON 格式传输可以简化客户端和服务器端的编程 Jquery和AJAXjQuery对ajax请求的创建、发送和响应都进 行了相应的封装，同时也考虑 了浏览器的兼容性问题 $.ajax()函数$.ajax({ url ：请求 地址, type ：请求 方式, async ：默认 true false 表示同步 请求, data ：请求 参数, dataType ：服务器返回的 数据类型, success ： 服务器 正常 处理时执行的 回调函 数, error ： 服务器处理出错时执行的 回调函 数, }); $.get()函数$.get(url，data，function，datatype) url：请求地址 data：请求参数 dataType：服务器返回的数据类型 function：服务器正常处理时执行的回调函数 $.post()函数$.post(url，data，function，datatype) url：请求地址 data：请求参数 dataType：服务器返回的数据类型 function：服务器正常处理时执行的回调函数 $.getJSON函数$.getJSON(url，data，function) url：请求地址 data：请求参数 function：服务器正常处理时执行的回调函数 load()函数$obj.load(url，data，function) url：请求地址 data：请求参数 function：ajax请求处理完毕后执行的回调函数 功能：利用ajax发送一个url请求，将返回结果填充到$obj元素中 （常用于页面引入)]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Quartz框架笔记]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Quartz%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Quartz是什么?Quartz是一个任务调度框架,是完全由java开发的一个开源的任务日程管理系统 Quartz特点 强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求； 灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式； 分布式和集群能力。 Quartz调度核心元素Scheduler（任务调度器） 实际执行任务调度的控制器。在spring中通过SchedulerFactoryBean封装起来 一个调度容器中可以注册多个JobDetail和Trigger Trigger（触发器） 用于定义任务调度的时间规则(什么时候去调)，有SimpleTrigger,CronTrigger,DateIntervalTrigger和NthIncludedDayTrigger，其中CronTrigger用的比较多 Calendar（特定时间点的集合） 一个trigger可以包含多个Calendar，以便排除或包含某些时间点 JobDetail（表示一个具体的可执行的调度程序） 在spring中有JobDetailFactoryBean和 MethodInvokingJobDetailFactoryBean两种实现，如果任务调度只需要执行某个类的某个方法，就可以通过MethodInvokingJobDetailFactoryBean来调用 Job（接口） 表示一个工作，要执行的具体内容。此接口中只有一个方法 void execute(JobExecutionContext context) 工作原理 原理流程步骤说明： 1：Scheduler是一个计划调度器容器（总部），容器里面可以放多个JobDetail和Trigger，当容器启动后，里面的每个JobDetail都会根据Trigger按部就班自动去执行。 2：JobDetail是一个可执行的工作，它本身可能是有状态的。 3：Trigger代表一个调度参数的配置，什么时候去调。 4：当JobDetail和Trigger在scheduler容器上注册后，形成了装配好的作业（JobDetail和Trigger所组成的一对儿），就可以伴随容器启动而调度执行了 5：Scheduler是个容器，容器中有一个线程池，用来并行调度执行每个作业，这样可以提高容器效率 整合spring步骤：1：加载quartz的类库jar包2：添加quartz的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;!-- 定时 --&gt; &lt;bean id=&quot;nextVisitMessageJob&quot; class=&quot;com.hjcrm.publics.task.NextVisitMessageJob&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;nextVisitMessageTask&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt; &lt;property name=&quot;targetObject&quot;&gt; &lt;ref bean=&quot;nextVisitMessageJob&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;targetMethod&quot;&gt; &lt;value&gt;nextVisitMessage&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;nextVisitMessageJobTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt; &lt;property name=&quot;jobDetail&quot;&gt; &lt;ref bean=&quot;nextVisitMessageTask&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;cronExpression&quot;&gt; &lt;value&gt;0/1 * * * * ?&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定时 --&gt; &lt;bean id=&quot;nextVisitMessageJob1&quot; class=&quot;com.hjcrm.publics.task.NextVisitMessageJob1&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;nextVisitMessageTask1&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt; &lt;property name=&quot;targetObject&quot;&gt; &lt;ref bean=&quot;nextVisitMessageJob1&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;targetMethod&quot;&gt; &lt;value&gt;demo09Job&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;nextVisitMessageJobTrigger1&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt; &lt;property name=&quot;jobDetail&quot;&gt; &lt;ref bean=&quot;nextVisitMessageTask1&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;cronExpression&quot;&gt; &lt;value&gt;0/1 * * * * ?&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 总管理类 如果将lazy-init=&apos;false&apos;那么容器启动就会执行调度程序 --&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;!-- &lt;ref bean=&quot;nextVisitMessageJobTrigger&quot;/&gt; --&gt; &lt;ref bean=&quot;nextVisitMessageJobTrigger1&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 关于cronExpression的介绍: s m h d m w(?) y(?) ,分别对应: 秒&gt;分&gt;小时&gt;日&gt;月&gt;周&gt;年 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ? / L C # 年（可选） 留空, 1970-2099 , - * / 表达式 意义 &quot;0 0/1 * * * ?&quot; 每1分钟触发 &quot;0 0 12 * * ?&quot; 每天中午12点触发 &quot;0 15 10 ? * *&quot; 每天上午10:15触发 &quot;0 15 10 * * ?&quot; 每天上午10:15触发 &quot;0 15 10 * * ? *&quot; 每天上午10:15触发 &quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 &quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 &quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 &quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 &quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 &quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 &quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 &quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 &quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 &quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 &quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发 &quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发 每天早上6点 0 6 * * * 每两个小时 0 */2 * * * 晚上11点到早上8点之间每两个小时，早上八点 0 23-7/2，8 * * * 每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 0 11 4 * 1-3 1月1日早上4点 0 4 1 1 * --&gt; &lt;/beans&gt; 3：spring配置文件中，引用quartz的配置文件 &lt;import resource=&quot;classpath:applicationContext-quartz.xml&quot;/&gt;]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Oracle笔记]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Oracle%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据库基础DB数据库(Database)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库。简单来说是本身可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、截取、更新、删除等操作。 关系型数据库商业型代表:Oracle DB2 SqlServer非商业型:Mysql 表结构 操作语言 Select语句 单行函数和组函数 分组查询 子查询 分页查询使用关键字rownum 多表查询JDBC JDBC全称为：Java Data Base Connectivity（java数据库连接） 相关APIDriverManager用于加载驱动，并创建与数据库的链接JDBC程序中的Connection，它用于代表数据库的链接JDBC程序中的Statement对象用于向数据库发送SQL语句JDBC程序中的ResultSet用于代表Sql语句的执行结果 释放资源 JDBC程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库 进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象 。 特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如 果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的 使用原则是尽量晚创建，尽量早的释放。 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。 事务事务的特性 原子性（Atomicity） – 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生， 要么都不发生。 一致性（Consistency） – 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation） – 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的 事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离 持久性（Durability） – 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的 ，接下来即使数据库发生故障也不应该对其有任何影响。 事务的隔离级别多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔 离操作，以保证各个线程在获取数据时的准确性 如果不考虑隔离性，可能会引发如下问题： 脏读：指一个事务读取了另外一个事务未提交的数据。 不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同。 虚读(幻读)：是指在一个事务内读取到了别的事务插入的数据，导致前后读 取不一致。 数据库共定义了四种隔离级别： – Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化） – Repeatable read（默认值）：可避免脏读、不可重复读情况的发生。（可 重复读） – Read committed：可避免脏读情况发生（读已提交）。 – Read uncommitted：最低级别，以上情况均无法保证。(读未提交) 数据库连接池]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Java笔记一SE基础]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Java%E7%AC%94%E8%AE%B0%E4%B8%80SE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaSE知识点梳理 JavaSE基础 计算机的体系结构基本概念 计算机俗称&quot;电脑&quot;，是一种被广泛使用在各个领域的设备。 计算机主要由：硬件 和 软件 两部分组成。 计算机中常见的硬件有：CPU、内存、硬盘、输入输出设备、... CPU---中央处理器，是计算机最核心的部件，相当于人的大脑 所有的运算都在CPU中进行 内存 —是计算机中的存储部件，用于存储CPU需要使用的相关数据。 该部件中存储的内容可以被CPU直接访问，并且效率比较高。 该部件中的数据不能永久存储，一旦关机都会造成数据的丢失。 使用ctrl+s快捷键可以进行数据的保存 硬盘 - 是计算机中的存储部件，该部件可以实现永久存储，通常不会造成数据的丢失 该部件中存储的内容不能被CPU直接访问，若希望访问则需要将数据加载到内存 科普：1Tb = 1024Gb1Gb = 1024Mb1Mb = 1024Kb1Kb = 1024byte(字节) 通常情况下单个英文字母占1个字节，单个汉字占2个字节1byte = 8bit(二进制位) 在计算机的底层只识别0和1组成的二进制序列 思考：目前主流的硬盘配置：250G 320G 500G 1Tb等，为啥我的硬盘只有298G呢？解析：硬件厂商在生产硬件时按照1000作为进率，操作系统是按照1024作为进率。 常见的软件 计算机的常见软件分为：系统软件 和 应用软件。 其中系统软件主要指操作系统，目前主流的主机操作系统：Windows/Linux/Unix系列 Windows系统：WinXp、Vista、Win7、Win8、Win8.1、Win10 目前移动终端的操作系统：Android、ios、windowsPhone 其中应用软件主要指安装在操作系统上的软件，如：火狐、记事本、计算器、QQ等 计算机的体系架构 使用者 =&gt; 应用软件 =&gt; 操作系统 =&gt; 硬件 =&gt; 操作系统分为：外壳(Shell) 和 内核(Kernel) Java语言的基本概述1 Java语言的产生背景 Java语言诞生于1995年，高斯林是公认的Java语言之父，隶属于sun公司，现在 隶属于oracle(甲骨文)公司。 2 Java语言的版本 Java SE（Java Platform, Standard Edition）称之为“Java平台标准版”，可以编写像office之类的桌面软件。 Java EE（Java Platform，Enterprise Edition）称之为“Java平台企业版”，可以编写具有B/S架构的项目和解决方案。 Java ME （Java Platform，Micro Edition）称之为Java 平台微型版，随着Android系统的普及走向淘汰。 3.开发环境的搭建和使用1 jdk的下载和安装(1)下载方式 a.从官网直接下载：www.sun.com/www.oracle.com b.从百度/谷歌/搜狗进行搜索下载(2)安装方式 a.若下载的安装版，则一路点击下一步即可。 b.若下载的绿色版，则直接解压即可。 切记不要有中文路径。 2 相关的概念 jdk - Java开发工具包，只要做Java语言的开发就必须安装该软件。 jre - Java运行时环境，只要运行Java程序就必须安装该软件。 javac.exe - Java语言编译器，用于将高级源代码文件编译为字节码文件。 java.exe - Java语言解释器，用于启动Java虚拟机对字节码文件进行边解释边执行。 JVM - Java虚拟机，用于作为Java语言和操作系统之间的桥梁。 3 编写Java程序的流程 (1) 新建文本文档，将文件的名称由xxx.txt修改为xxx.java。 (2) 使用记事本的方式打开文件，编辑Java代码后保存。 (3) 启动dos窗口，将路径切换到xxx.java所在的目录。 (4) 使用javac xxx.java进行编译，生成xxx.class的字节码文件。 (5) 使用java xxx进行解释执行，打印最终的结果。 注意： 若文本文档没有显示.txt后缀时，则具体处理如下： 组织 =&gt; 文件夹和搜索选项 =&gt; 查看 =&gt; 隐藏已知文件名的扩展名 =&gt; 去掉勾选 =&gt;确定 4 常用的快捷键 ctrl+s 保存 ctrl+a 全选 ctrl+c 复制 ctrl+v 粘贴 ctrl+x 剪切 ctrl+f 查找 ctrl+z 撤销 windows+d 打开桌面 windows+e 打开计算机 windows+l 锁屏 windows+r 打开运行，输入cmd后回车，就可以启动dos窗口 windows+tab 切换任务 alt+tab 切换任务 ctrl+alt+delete 打开任务管理器 ctrl+shift 切换输入法，若切换到中文输入法后就可以使用shift进行中英文切换 5 常用的dos命令 d: 表示切换到d盘 cd 目录名/路径 表示切换到指定的目录中 dir 表示查看当前目录的内容 cls 表示清屏 cd .. 表示切换到上一级目录 6 环境变量的配置基本概念通常情况下的可执行文件需要在该文件所在的目录中才能使用，为了使得该可执行文件可以在任意的位置直接使用，此时就需要配置环境变量Path。 配置方式计算机 =&gt; 鼠标右击 =&gt; 属性 =&gt; 高级系统设置 =&gt; 高级 =&gt; 环境变量 =&gt; 系统变量=&gt; 找到Path，点击编辑 =&gt; 将javac.exe所在的路径拷贝到Path变量值的最前面，添加分号=&gt; 一路点击确定即可切记Path变量值原来的内容不要改！配置环境变量后记得重启dos窗口！ 7 Java语言的跨平台特性由于不同的操作系统中都提供了Java虚拟机进行解释执行，因此对于同一份字节码文件来说，可以实现一次编译，到处运行的美名。 编码:编写第一个java程序Hello world public class helloWorld(){ public static void main(String args){ system.out.println(&quot;Hello world&quot;); } } 变量1 变量的基本概念当需要在程序中记录单个数据内容时，则声明一个变量来记录即可，而变量的本质就是在内存中申请一块存储单元，并且该区域中的数据内容可以发生改变，因此得名为 变量。由于存储的数据内容不同导致所需的内存空间大小不同，在Java语言中使用数据类型的概念加以描述，并指定该区域一个变量名的概念来记录地址信息。2 变量的声明方式 数据类型 变量名 = 初始值; - 其中=初始值可以省略，但;不可以省略。 如： String name = &quot;xiaomage&quot;; - 推荐该方式 int age = 18; int age; 注意：在main()方法体中直接声明的变量叫做 局部变量，局部变量的作用域为：从声明开始一直到该方法体结束。 3 标识符(变量名)的命名规则 由字母、数字、下划线以及美元$组成，其中数字不能开头。如：name age id country name2 name3 等 不能与Java语言中的关键字同名，关键字就是Java语言中用于代表特殊含义的单词。如：class int void static 等 区分大小写，长度没有限制但不宜过长。如：Day 和 day代表两个不同的变量名，不推荐使用 尽量做到见名知意，支持中文但不推荐使用。如：sendMsgToAll 数据类型基本分类 在Java语言中将数据类型分为两大类：基本数据类型：byte、short、int、long、float、double、char、boolean。引用数据类型：数组、类、接口、枚举以及标注。 常见的进制在日常生活中采用十进制，逢十进一，每个十进制数字的权重：10^0、10^1、10^2、…在计算机的底层采用二进制，逢二进一，每个二进制数字的权重：2^0、2^1、2^2、…为了简化二进制的表示形式，通常会采用八进制和十六进制来描述。 在二进制中操作最高位(最左边)代表符号位，使用0代表非负数，使用1代表负数。 进制之间的转换(尽量掌握、原理)1 正十进制转换为正二进制的方式a.除2取余法，让十进制整数不断地除以2记录余数，直到商为0将所有余数逆序排列。b.拆分法，将十进制整数拆分为若干个二进制权重的和，若有该权重则下面写1，否则写0。 如： 34 = 32 + 2 128 64 32 16 8 4 2 1 0 0 1 0 0 0 1 0 =&gt; 0010 0010 2 正二进制转换为正十进制的方式a.加权法，让二进制的每个数字乘以当前位的权重，再将所有乘积累加起来即可。 如： 0010 0010 =&gt; 0*2^7 + 0*2^6 + 1*2^5 + 0*2^4 + 0*2^3 + 0*2^2 + 1*2^1 + 0*2^0 =&gt; 0 + 0 + 32 + 0 + 0 + 0 + 2 + 0 =&gt; 34 3 负十进制转换为负二进制的方式a.将十进制整数的绝对值转换为二进制，然后进行按位取反再加1。 如： -34 转换为二进制的结果： 34转换为二进制： 0010 0010 按位取反： 1101 1101 再加1： 1101 1110 34: 0010 0010 -34: 1101 1110 + 1 0000 0000 (若只保留低8位二进制，则最高位的1溢出/丢弃， 结果是：0 ) 4 负二进制转换为负十进制的方式a.先减1再按位取反，然后采用加权法合并为十进制整数，最后添加负号。 如： 1101 1110转换为十进制： 先减1： 1101 1101 按位取反：0010 0010 合并十进制整数：34 最后添加负号： -34 解析： 1个二进制位： 0 1 2个二进制位： 00 01 10 11 3个二进制位： 000 001 010 011 100 101 110 111 5 二进制转换为八进制的方式(了解) a.将每三位二进制合并为一位八进制，并使用0作为八进制的前缀。 如： 010 001(二进制) =&gt; 021(八进制) 6 八进制转换为二进制的方式(了解) a.将每一位八进制拆分为三位二进制，并使用0b作为二进制的前缀(jdk1.7的新特性)。 如： 063(八进制) =&gt; 0b110 011(二进制) 7 二进制转换为十六进制的方式(了解) a.将每四位二进制合并为一位十六进制，并使用0x作为十六进制的前缀。 如： 1010 0111(二进制) =&gt; 0xa7(十六进制，使用a~f来代表10~15之间的整数) 8 十六进制转换为二进制的方式(了解) a.将每一位十六进制拆分为四位二进制，并使用0b作为二进制的前缀。 如： 0xc9(十六进制) =&gt; 0b1100 1001 单个字节表示的整数范围(重中之重)在计算机中单个字节占8位二进制位，最高位表符号位，0表非负数，1表负数，具体如下: 非负数的表示范围是：0000 0000 ~ 0111 1111 =&gt; 0 ~ 127 =&gt; 0 ~ 2^7-1 0000 0000 =&gt; 0 0111 1111 =&gt; 0*2^7 + 1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0 =&gt; 64 + 32 + 16 + 8 + 4 + 2 + 1 =&gt; 127 负数的表示范围是：1000 0000 ~ 1111 1111 =&gt; -128 ~ -1 =&gt; -2^7 ~ -2^0 1000 0000 =&gt; 减1：0111 1111 =&gt; 按位取反：1000 0000 =&gt; 转换十进制：128 =&gt; 添加负号： -128 1111 1111 =&gt; 减1：1111 1110 =&gt; 按位取反：0000 0001 =&gt; 转换十进制：1 =&gt; 添加负号： -1 综上所述： 对于单个字节来说，所能表示的十进制整数范围是：-128 ~ 127 =&gt; -2^7 ~ 2^7-1. 整数类型(重点)在Java语言中用于描述整数数据的类型有：byte、short、int、long，推荐使用int类型。 其中byte类型在内存空间中占1个字节的大小，因此表示范围是：-2^7 ~ 2^7-1. -128 ~ 127. 其中short类型在内存空间占2个字节的大小，因此表示范围是： -2^15 ~ 2^15-1. -32768 ~ 32767. 其中int类型在内存空间占4个字节的大小，因此表示范围是：-2^31 ~ 2^31-1. 正负二十一亿之间. 其中long类型在内存空间占8个字节的大小，因此表示范围是：-2^63 ~ 2^63-1. 比int类型还大的数. 在Java程序中直接写出的整数数据叫做 直接量/字面值/常量，如：66，默认为int类型，若希望表达更大的直接量，则需要在直接量的后面加上l或者L，推荐使用L。 浮点类型(重点)在Java语言中用于描述小数数据的类型有：float、double，推荐使用double类型。 其中float类型在内存空间中占4个字节，叫做单精度浮点数，通常小数点后可以取到7位。 其中double类型在内存空间中占8个字节，叫做双精度浮点数，通常小数点后可以取到14位 在Java程序中直接写出的小数数据叫做直接量，默认为double类型，如：3.14，若希望表达float类型的直接量，则需要在直接量后面加上f或者F. 扩展： 由于float类型和double类型无法实现精确计算，因此商业开发中需要借助java.math.BigDecimal类型加以描述。 查询float和double类型的底层结构。 布尔类型(重点)在Java语言中用于描述真假信息的类型有：boolean，数值只有：true(真) 和 false(假)其中boolean类型占用内存空间的大小没有明确的规定，通常认为是1个字节。 字符类型(重点)在Java语言中用于描述字符信息的类型有：char，如：’1’，’a’，’中’等。其中char类型占用内存空间的大小为2个字节，在以后的开发中char类型很少使用，使用更多的是多个字符组成的字符串，使用””括起来，并且用String类型加以描述。 为了使得字符能够有效地记录到计算机中，给每个字符指定了一个编号，叫做 ASCII值. 要求记住的ASCII值有： &apos;0&apos; - 48 &apos;A&apos; - 65 &apos;a&apos; - 97 空格 - 32 换行符 - 10 要求大家记住的转义字符有： \&quot; - &quot; \&apos; - &apos; \\ - \ \t - 制表符(tab键) \n - 换行符 基本数据类型之间的转换(尽量理解)在Java语言中数据类型之间的转换分为两大类： 自动类型转换 - 主要指从小范围到大范围之间的转换。 强制类型转换 - 主要指从大范围到小范围之间的转换。 - 目标类型 变量名 = (目标类型)源类型的变量名。 - byte b1 = (byte)s1; - 尽量少使用强制类型转换，因为可能会造成数据的丢失。 运算符算术运算符— + - * / %表示取模/取余运算符 注意： 当两个整数进行除法运算时，结果只取整数部分，丢弃小数部分； 若希望保留小数部分则处理方式如下： 将其中一个操作数强转为double类型后再进行除法运算。 将其中一个操作数乘以1.0后再进行除法运算(推荐)。 0不能做除数，0.0可以做除数但结果是无穷大，因此通常不建议使用 +运算符既可以表示加法运算符也可以表示字符串连接符，具体区别如下： 1 若+运算符两边的操作数没有任何一个是字符串类型时，则按照加法运算符来处理； 2 若+运算符两边的操作数只有有一个是字符串类型，则按照字符串连接符来处理； 关系/比较运算符&gt; 表示是否大于运算符 &gt;= 表示是否大于等于运算符 &lt; 表示是否小于运算符 &lt;= 表示是否小于等于运算符 == 表示是否等于运算符 != 表示是否不等于运算符 所有以关系运算符为最终运算的表达式结果一定是boolean类型，只有：true 和 false。 3 自增减运算符 + 表示加法运算符 ++ 表示自增运算符，让变量自身的数值加1 - 表示减法运算符 -- 表示自减运算符，让变量自身的数值减1 逻辑运算符&amp;&amp; 表示逻辑与运算符，相当于&quot;并且&quot;，只有运算符两边的结果都为真，最终的结果才为真 - 同真为真，一假为假 || 表示逻辑或运算符，相当于&quot;或者&quot;，只要运算符两边的结果有一个为真，最终结果为真 - 一真为真，同假为假 ! 表示逻辑非运算符，相当于&quot;取反&quot;，真为假，假为真。 短路特性： 对于逻辑与运算符来说，若第一个条件为假则整个表达式一定为假，第二个条件跳过不执行对于逻辑或运算符来说，若第一个条件为真则整个表达式一定为真，第二个条件跳过不执行 条件运算符?: - 表示条件运算符，又叫做三目运算符。 条件表达式 ? 表达式1: 表达式2 =&gt; 判断条件表达式是否成立，若成立则执行表达式1，否则执行表达式2 赋值运算符1 简单赋值 = 表示赋值运算符，用于将=右边的数值赋值给=左边的变量，切记不要与==混淆。 笔试题： ia == 2; - 表示判断ia是否等于2 2 == ia; - 表示判断2是否等于ia ia = 2; - 表示将数值2赋值给变量ia，覆盖ia原来的数值 2 = ia; - 编译报错 2 复合赋值 += -= *= /= ... 如： ia = ia + 2; =&gt; ia += 2; 从结果上来说等价. 笔试题： byte b1 = 2; b1 += 2 真正等价的是： b1 = (byte)(b1 + 2); 移位运算符(了解)&lt;&lt; 表示按照二进制位向左移动右边填0，叫做左移运算符 &gt;&gt; 表示按照二进制位向右移动左边填符号位，叫做右移运算符 &gt;&gt;&gt; 表示按照二进制位向右移动左边填0，叫做无符号右移运算符 位运算符(了解)&amp; 表示按位与运算符，同1为1，一0为0(1看做真，0看做假).| 表示按位或运算符，一1为1，同0为0.~ 表示按位取反运算符，1为0，0为1.^ 表示按位异或运算符，相同为0，不同为1. 运算符的优先级(1) ()的优先级极高;(2) =的优先级极低;(3) * / %的优先级高于+ -，同级的哪个在前先算哪个; 分支结构基本概念 在某些特殊场合中根据判断的条件是否成立来决定是否执行某段代码的结构，叫做分支结构 if分支结构(1)语法格式 if(条件表达式){ 语句块; } (2)执行流程 判断条件表达式是否成立 =&gt; 若成立，则执行语句块； =&gt; 若不成立，则分支结构结束； if-else分支结构(1)语法格式 if(条件表达式){ 语句块1; } else{ 语句块2; } (2)执行流程 判断条件表达式是否成立 =&gt; 若成立，则执行语句块1； =&gt; 若不成立，则执行语句块2； if-else if-else分支结构(1)语法格式 if(条件表达式1){ 语句块1; } else if(条件表达式2){ 语句块2; } ... ... else{ 语句块n; } (2)执行流程 判断条件表达式1是否成立 =&gt; 若成立，则执行语句块1； =&gt; 若不成立，则判断条件表达式2是否成立 =&gt; 若成立，则执行语句块2； =&gt; 若不成立，则执行语句块n； switch-case分支结构(1)语法格式 switch(变量/表达式){ case 直接量1: 语句块1; break; case 直接量2: 语句块2; break; ... ... default: 语句块n; } (2)执行流程 计算变量/表达式的数值 =&gt; 判断是否与直接量1匹配 =&gt; 若匹配，则执行语句块1 =&gt; 执行break跳出该结构； =&gt; 若不匹配，则判断是否与直接量2匹配 =&gt; 若匹配，则执行语句块2 =&gt; 执行break跳出该结构； =&gt; 若不匹配，则执行语句块n; 注意事项switch()中支持的类型有：byte、short、char以及int类型，从jdk1.5开始支持枚举类型，从jdk1.7开始支持String类型。 循环结构基本概念 当需要在程序中重复执行一段代码时，则使用循环结构。 for循环(1)语法格式 for(初始化表达式; 条件表达式; 修改初始值表达式){ 循环体; } (2)执行流程 执行初始化表达式 =&gt; 判断条件表达式是否成立 =&gt; 若成立，则执行循环体 =&gt; 执行修改初始值表达式 =&gt; 判断条件表达式是否成立 =&gt; 若不成立，则循环结束 break和continue break关键字可以用在switch-case分支结构和循环结构中，用于跳出当前循环。 continue关键字可以用在循环结构中表示结束本次循环继续下一次循环(熟悉)。 特殊的循环for(;;) - 这种没有明确循环条件的循环叫做无限循环，俗称&quot;死循环&quot;。 该循环通常与break关键字搭配使用 双重for循环(1)语法格式 for(初始化表达式1; 条件表达式2; 修改初始值表达式3){ for(初始化表达式4; 条件表达式5; 修改初始值表达式6){ 内层循环的循环体; } } (2)执行流程 执行表达式1 =&gt; 判断表达式2是否成立 =&gt; 若成立，则执行表达式4 =&gt; 判断条件表达式5是否成立 =&gt; 若成立，则执行循环体 =&gt; 执行表达式6 =&gt; 判断条件表达式5是否成立 =&gt; 若不成立，则内层循环结束 =&gt; 执行表达式3 =&gt; 判断表达式2是否成立 =&gt; 若不成立，则外层循环结束 while循环(1)语法格式 while(条件表达式){ 循环体; } (2)执行流程 判断条件表达式是否成立 =&gt; 若成立，则执行循环体 =&gt; 判断条件表达式是否成立 =&gt; 若不成立，则循环结束 (3)注意事项 a.while循环和for循环可以完全互换； b.while循环通常使用在明确循环条件不明确循环次数的场合中； for循环通常使用在明确循环次数但不明确循环条件的场合中； c.while(true)等价于for(;;)都表示无限循环； do-while循环 (1)语法格式 do{ 循环体; }while(条件表达式); (2)执行流程 执行循环体 =&gt; 判断条件表达式是否成立 =&gt; 若成立，则执行循环体 =&gt; 判断条件表达式是否成立 =&gt; 如不成立，则循环结束 (3)注意事项 do-while循环主要用于至少执行一次循环体的场合中; 一维数组(重点)基本概念 当需要在程序中记录单个数据时，则声明一个变量来记录即可； 当需要在程序中记录多个类型相同的数据时，则声明一个一维数组来记录，而一维数组的本质就是在内存中申请一段连续的存储空间，每个存储单元负责记录一个数据。 数组名称 - 主要用于记录该连续内存空间的首地址，代表该数组。 数组元素 - 主要指存放在数组中的数据内容。 数组长度 - 主要指该数组可以存放的元素个数，通常使用 数组名.length 的方式获取。 数组下标 - 主要指数组元素在数组中的编号，从0开始 一直到 数组名.length-1。 数组的声明 (1)语法格式 数据类型[] 数组名称 = new 数据类型[数组的长度]; - 动态方式 如： int[] arr = new int[5]; - 声明一个长度为5元素类型为int类型的一维数组 int num = 5; - 声明一个int类型的变量num，初始值为5 int arr[] = new int[5]; - 不推荐使用 double[] arr = new double[3]; - 声明一个长度为3元素类型为double类型的一维数组 注意： 只有在声明数组时[]中的数字才代表数组的长度，否则一律代表数组的下标； (2)数组元素的初始化 数据类型[] 数组名称 = {初始值1, 初始值2, ...}; - 静态方式 如： int[] arr = {10, 20, 30}; - 声明一个长度为3元素类型为int类型的一维数组 该数组元素的初始值为：10 20 30 二维数组基本概念 一维数组本质上就是一段连续内存空间，用于存放多个类型相同的数据内容。二维数组本质上就是由一维数组组成的数组，换句话说，二维数组中的每个元素都是一个一维数组，而一维数组的每个元素才是具体的数据内容。 声明方式 (1)语法格式 数据类型[][] 数组名称 = new 数据类型[行数][列数]; 如： int[][] arr = new int[2][3]; - 声明一个具有2行3列元素类型为int类型的二维数组 其中行下标范围是：0 ~ 1; 其中列下标范围是：0 ~ 2; 思考： arr代表什么？ arr[0]代表什么？ arr[0][0]代表什么？ 解析： arr表示二维数组的名称，代表连续内存空间的首地址 arr[0]表示二维数组的第一行，也就是一个一维数组 arr[0][0]表示二维数组的第一行第一列，也就是第一个数据内容 arr.length代表二维数组的大小，也就是元素/一维数组的个数，换句话说，二维数组行数 arr[0].length代表二维数组第一行的大小，也就是一维数组的大小，换句话说，就是列数 (2)初始化 数据类型[][] 数组名称 = {{初始值1,初始值2, ...}, ...}; 如： int[][] arr = {{1, 2, 3}, {4, 5, 6}};]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Java笔记三核心类库一]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Java%E7%AC%94%E8%AE%B0%E4%B8%89%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%E4%B8%80%2F</url>
    <content type="text"><![CDATA[核心类库一: 抽象类抽象方法的概念抽象方法就是指不能具体实现的方法，也就是该方法没有方法体，使用abstract关键字修饰具体语法格式如下：访问控制符 abstract 返回值类型 方法名称(形参列表); 如： public abstract void cry(); 抽象类的概念抽象类就是指不能具体实现的类，也就是该类不能实例化对象，使用abstract关键字修饰 注意事项 抽象类中可以有成员变量、成员方法以及构造方法等。 抽象类中可以没有抽象方法，也可以有抽象方法。 拥有抽象方法的类必须是抽象类，否则编译报错，因此很多资料上认为拥有抽象方法并且使用abstract关键字修饰的类才称之为真正意义上的抽象类。 实际意义抽象类的实际意义不在于创建对象而在于被继承，当一个类继承抽象类之后则必须要重写抽象方法，否则该类也要变成抽象类。因此抽象类对子类具有强制性和规范性，通常叫做 模板设计模式。 经验分享：在以后的开发中推荐使用父类引用指向子类对象的形式，因为父类引用可以直接调用的方法一定是父类拥有的方法，若以后更换子类时，只需要将new运算符后面的类型更改即可，其它所有位置的代码不用更改立即生效，从而提高了代码的可维护性。该方式的缺点在于父类的引用不能直接调用子类独有的方法，若调用则需要强制类型转换。 接口(重点)基本概念接口本质上就是一种比抽象类还抽象的类，因此不能实例化对象。 定义类的关键字是class，而定义接口的关键字是interface。 继承类的关键字是extends，而实现接口的关键字是implements。 注意事项 接口中的所有成员变量都必须由public static final共同修饰，也就是常量； 接口中的所有成员方法都必须由public abstract共同修饰，也就是抽象方法； 类和接口之间的关系 类和类之间的关系 使用extends关键字 支持单继承 类和接口之间的关系 使用implements关键字 支持多实现 接口和接口之间的关系 使用extends关键字 通常看做单继承 抽象类和接口的主要区别(笔试题) (1)定义抽象类的关键字是class，而定义接口的关键字是interface. (2)继承抽象类使用extends，而实现接口使用implements. (3)抽象类中可以有构造方法，而接口中没有构造方法。 (4)抽象类中可以有成员变量，而接口中只能有常量。 (5)抽象类中可以有成员方法，而接口中只能有抽象方法。 (6)继承抽象类只能单继承，而实现接口可以多实现。 (7)接口中增加方法一定会影响子类，而抽象类中增加方法可以不影响子类。 内部类(了解)基本概念将一个类的定义放在另外一个类的内部时，这个被放入的类叫做内部类，而该类所在的类叫做外部类。类体中可以存在的内容：成员方法、成员方法、构造方法、构造块和静态语句块、内部类等 语法格式 class 类名{ class 类名{ 内部类的类体; } } 基本作用当一个类存在的价值仅仅是为某一个类单独服务时，则可以将这个类作为所服务类的内部类，内部类可以直接访问所在类的私有成员，而不再需要提供公有的get和set方法。 基本分类普通内部类 - 直接将一个类的定义放在另外一个类的内部。静态内部类 - 使用static关键字修饰的内部类。 只有内部类才可以使用static关键字修饰，普通类不能修饰。局部内部类 - 直接将一个类的定义放在一个方法体的内部。 该类只在方法体内部有效。匿名内部类 - 指没有名字的内部类。 匿名内部类(重点、难点)语法格式 接口/父类类型 引用变量名 = new 接口/父类类型(){ 方法的重写; }; 经验的分享 当接口类型的引用作为方法的形参时，实参的传递方式有两种：a.自定义类实现接口并重写抽象方法，然后new实现类的对象作为实参传递。b.使用匿名内部类的语法格式直接得到接口类型的引用作为实参传递。 Object类(重点) 基本概念java.lang.Object类是类层次结构的根类，任何类都是该类的直接或间接子类。 常用的方法 Object() - 无参构造方法，主要用于子类通过super()的方式调用。 boolean equals(Object obj) - 用于判断调用对象是否与参数对象相等。 - 该方法默认比较对象的地址，与==的效果等价。 - 若希望该方法去比较两个对象的内容，则需要重写该方法。 - 当该方法重写后，通常有必要去重写hashCode()方法。 - int hashCode() - 用于获取调用对象的哈希码值(内存地址的编号)。 - 当两个对象调用equals()方法相等时，则各自调用hashCode()的结果必须相同。 - 当两个对象调用equals()方法不相等时，则各自调用hashCode()的结果应该不相同。 String toString() - 用于返回调用对象的字符串形式。 - 该方法默认返回：包名.类名@哈希码值的十六进制形式。 - 若希望打印其他内容则需要进行方法的重写。 - 当使用print()/println()方法打印引用或者让字符串拼接引用时，自动调用该方法 包装类和数学处理类 如： Person p = new Person(); - 表示声明Person类型的引用指向Person类型的对象。 int num = 66; - 表示声明int类型的变量num初始值为66。 Java语言是一门纯面向对象的编程语言。 基本概念 在某些特殊场合(集合)中，要求存取的数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得这些数据能够存取就需要进行对象化处理，而包装类就是用于将基本数据类型的变量打包成对象的类。 Integer类(重点)1 基本概念 java.lang.Integer类实现了对int类型的包装，该类由final关键字修饰表示不能被继承。 2 常用的方法 Integer(int value) - 根据参数指定的整数构造对象。 Integer(String s) - 根据字符串来构造对象对象。 该类重写了equals()、hashCode()以及toString()方法。 int intValue() - 用于返回当前对象中包含的整数数据。 static Integer valueOf(int i) - 用于根据参数指定的整数得到Integer对象并返回。 static int parseInt(String s) - 用于将String类型转换为int类型并返回。 3 装箱和拆箱 装箱就是指从int类型向Integer类型转换的过程。拆箱就是指从Integer类型向int类型转换的过程。 从jdk1.5开始支持了自动装箱和自动拆箱的机制，直接使用赋值运算符完成该操作。 4 自动装箱池(尽量理解) 为了提高自动装箱的效率，在Integer类的内部将-128到127之间的整数提前装箱并放入自动装箱池中，若程序中出现该范围的整数则直接从池中获取并使用，否则才需要创建新的对象。 BigDecimal类(查手册会用即可)1 基本概念 由于float类型和double类型无法实现精确计算，因此商业开发中需要借助java.math.BigDecimal类型加以描述。 2 常用的方法 BigDecimal(String val) - 根据参数指定的字符串内容来构造对象。 BigDecimal add(BigDecimal augend) - 用于计算调用对象和参数对象数值相加的和并返回。 BigDecimal subtract(BigDecimal subtrahend) - 用于计算调用对象和参数对象数值相减的差并返回。 BigDecimal multiply(BigDecimal multiplicand) - 用于计算调用对象和参数对象数值相乘的积并返回。 BigDecimal divide(BigDecimal divisor) - 用于计算调用对象和参数对象数值相除的商并返回。 BigInteger类(查手册会用即可)1 基本概念 若希望表达比long类型还大的数据，则借助java.math.BigInteger类型加以描述。 2 常用的方法 BigInteger(String val) - 根据参数指定的字符串内容来构造对象。 BigInteger add(BigInteger val) - 用于计算调用对象和参数对象的和并返回。 BigInteger subtract(BigInteger val) - 用于计算调用对象和参数对象的差并返回。 BigInteger multiply(BigInteger val) - 用于计算调用对象和参数对象的积并返回。 BigInteger divide(BigInteger val) - 用于计算调用对象和参数对象的商并返回。 BigInteger[] divideAndRemainder(BigInteger val) - 用于计算调用对象和参数对象的商和余数共同组成数组并返回。 String类(重中之重)基本概念java.lang.String类由final关键字修饰，表示不能被继承。该类的实例可以描述Java应用程序中所有的字符串字面值，如：”abc”。该类描述的字符串内容是个常量，一旦创建完毕则无法更改。 如： String s1 = &quot;hello&quot;; s1 = &quot;world&quot;; - 更改变量s1的指向而不是指向的内容，内容始终不变。 如： String s1 = &quot;&quot;; - 空字符串，有对象但没有内容 String s1 = null; - 没有对象 常用的构造方法String() - 使用无参的方式来构造空对象。 String(byte[] bytes) - 根据参数指定的byte数组来构造对象。 String(byte[] bytes, int offset, int length) - 根据byte数组中从offset位置开始的length个字节来构造对象。 String(char[] value) - 根据参数指定的char数组来构造对象。 String(char[] value, int offset, int count) - 根据char数组中从offset位置开始的count个字符来构造对象。 String(String original) - 根据参数指定的字符串内容来构造对象。 常用的成员方法该类重写了equals()、hashCode()以及toString()方法。 char charAt(int index) - 根据参数指定的下标返回对应的单个字符。 int length() - 用于返回当前字符串的长度。 int compareTo(String anotherString) - 用于比较调用对象和参数对象的大小关系。 - 使用调用对象和参数对象中第一个字符起依次做减法运算 - 若第一个字符能确定大小，则后续字符不用比较 - 若第一个字符不能确定大小，则使用下一个对应位置的字符比较大小。 - 直到其中一个字符串的所有字符比较完毕后也没有确定大小，则由长度来决定大小。 - 若当前字符串大则返回正数；若当前字符串小则返回负数；若相等则返回零； int compareToIgnoreCase(String str) - 不考虑大小写，也就是&apos;a&apos;和&apos;A&apos;是相等的关系。 boolean contains(CharSequence s) - 用于判断当前字符串是否包含参数指定的内容。 - 其中参数是接口类型，因此实参需要传递实现类的对象，而String类就实现了该接口 boolean endsWith(String suffix) - 判断当前字符串是否以参数指定的内容为结尾。 boolean startsWith(String prefix) - 判断当前字符串中是否以参数指定的内容为开头。 String toLowerCase() - 用于将当前字符串中所有字符转换为小写。 String toUpperCase() - 用于将当前字符串中所有字符转换为大写。 String trim() - 用于去除当前字符串中两端的空白字符。 boolean equals(Object anObject) - 用于比较字符串内容是否相等并返回； boolean equalsIgnoreCase(String anotherString) - 用于比较字符串内容是否相等并返回，不考虑大小写，如：&apos;A&apos;和&apos;a&apos;是相等。 byte[] getBytes() - 用于将当前字符串内容转换为byte数组并返回。 char[] toCharArray() - 用于将当前字符串内容转换为char数组并返回。 int indexOf(int ch) - 用于返回当前字符串中参数ch指定的字符第一次出现的下标。 int indexOf(int ch, int fromIndex) - 用于从fromIndex位置开始查找ch指定的字符。 - 上述方法若查找失败，则返回-1. int indexOf(String str) - 用于查找参数str指定的字符串并返回下标。 int indexOf(String str, int fromIndex) - 用于从fromIndex位置开始查找。 int lastIndexOf(int ch) - 用于返回参数ch指定的字符最后一次出现的下标。 int lastIndexOf(int ch, int fromIndex) - 用于从fromIndex位置开始查找ch指定字符出现的下标，反向搜索的第一次。 int lastIndexOf(String str) - 用于返回str指定字符串最后一次出现的下标。 int lastIndexOf(String str, int fromIndex) - 用于从fromIndex位置开始反向搜索的第一次。 String substring(int beginIndex) - 用于获取当前字符串中从beginIndex位置开始的子字符串并返回。 String substring(int beginIndex, int endIndex) - 用于获取当前字符串中从beginIndex位置开始到endIndex结尾的子字符串并返回。 正则表达式(熟悉、JS)基本概念 正则表达式本质上就是一个字符串，通常使用^开头$结尾，主要用于对用户输入的数据格式进行验证，不对内容验证。 常用的格式 [abc] - 表示可以出现a、b 或 c。 [^abc] - 表示可以出现任何字符，除了 a、b 或 c。 [a-zA-Z] - 表示可以出现a 到 z 或 A 到 Z，两头的字母包括在内。 \d - 表示可以出现任何数字：[0-9]。 \D - 表示可以出现任何非数字： [^0-9]。 \s - 表示可以出现任何空白字符：[ \t\n\x0B\f\r]。 \S - 表示可以出现任何非空白字符：[^\s] \w - 表示可以出现任何单词字符：[a-zA-Z_0-9] \W - 表示可以出现任何非单词字符：[^\w] X? - 表示X可以出现一次或一次也没有，也就是0 ~ 1次。 X* - 表示X可以出现零次或多次，也就是0 ~ n次。 X+ - 表示X可以出现一次或多次，也就是1 ~ n次。 X{n} - 表示X出现恰好 n 次。 X{n,} - 表示X出现至少 n 次，也就是&gt;=n次。 X{n,m} - 表示X出现至少 n 次，但是不超过 m 次，也就是&gt;=n并且&lt;=m。 常用的方法 boolean matches(String regex) - 用于判断当前字符串是否匹配参数指定的正则表达式。 StringBuilder类和StringBuffer类(查手册会用即可)基本概念由于String类描述的字符串是个常量不可更改，当程序中出现大量相似的字符串时，对内存空间的消耗比较大，为了节省内存空间直接对字符串本身更改，则需要借助StringBuilder类和StringBuffer类。StringBuffer类是jdk1.0开始就有的类，属于线程安全的类，因此效率比较低。StringBuilder类是jdk1.5开始有的类，属于非线程安全的类，因此效率比较高。 常用的方法 StringBuilder(String str) - 根据参数指定的字符串内容来构造对象。 - 初始容量为：16 + str的长度。 StringBuilder insert(int offset, String str) - 用于将参数指定的字符串str插入到当前字符串中下标为offset的位置。 - 用于当前字符串自身。 StringBuilder append(String str) - 用于将参数指定的字符串str追加到当前字符串的末尾。 StringBuilder delete(int start, int end) - 用于将当前字符串中从start位置开始到end位置结束之间的内容删除。 StringBuilder replace(int start, int end, String str) - 用于将当前字符串中start到end之间的内容使用str进行替换。 StringBuilder reverse() - 用于将当前字符串中的内容进行反转。 int capacity() - 用于返回当前字符串对象的容量。 int length() - 用于返回字符串的长度。 日期相关的类(查询手册会用即可) Date类1 基本概念 java.util.Date类用于描述特定的瞬间，可以精确到毫秒。 2 常用的方法 Date() - 无参构造方法，默认使用当前系统时间来构造对象。 Date(long msec) - 根据参数指定的毫秒数来构造对象。 - 其中参数为距离1970年1月1日0时0分0秒的毫秒数。 long getTime() - 用于获取当前调用对象距离上述标准时间的毫秒数并返回。 void setTime(long msec) - 用于设置当前调用对象表示的时间为参数指定的毫秒数。 SimpleDateFormat类1 基本概念 java.text.SimpleDateFormat类用于实现日期类型和文本类型之间的转换。 2 常用的方法 SimpleDateFormat(String pattern) - 根据参数指定的模式/格式来构造对象。 - 其中模式字符串可以有：y代表年，M代表月,d代表日，H代表时,m代表分，s代表秒 public final String format(Date date) - 用于将Date类型转换为String类型并返回。 public Date parse(String source) - 用于将String类型转换为Date类型并返回。 Calendar类1 基本概念 java.util.Calendar类用于取代Date类中的过时方法进行日期和时间的处理。 2 常用的方法 static Calendar getInstance() - 获取Calendar类型的对象。 void set(int year, int month, int date, int hourOfDay, int minute, int second) - 用于设置年月日时分秒信息。 Date getTime() - 将调用对象转换为Date类型并返回。]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Java笔记三核心类库三]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Java%E7%AC%94%E8%AE%B0%E4%B8%89%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%E4%B8%89%2F</url>
    <content type="text"><![CDATA[线程 基本概念 程序 - 数据结构 + 算法，主要指存放在硬盘上的可执行文件。进程 - 主要指运行在内存中的程序。目前主流的操作系统都支持多进程，是为了让操作系统同时执行多个任务，但进程是重量级的，新建进程对CPU和内存等系统资源的消耗比较大，因此进程的数量是有限的。线程就是进程内部的程序流，也就是说操作系统中支持多进程，而每个进程中又可以支持多线程，并且线程是轻量级的，新建线程会共享所在进程的资源，因此对资源的消耗比较小，以后的开发中基本都采用多线程的技术。目前主流的操作系统都采用时间片轮转法来保证多个任务的同时执行，叫做并发执行，也就是宏观并行，微观串行的技术。 线程的创建(重中之重) 1 Thread类java.lang.Thread类用于描述线程，Java虚拟机中允许运行多个线程。 创建线程并启动的方式有两种： 自定义类继承Thread类并重写run()方法，创建该类的对象调用start()方法。 自定义类实现Runnable接口并重写run()方法，创建该类的对象作为创建Thread类对象的实参，然后使用Thread类的对象去调用start()方法。 2 相关的方法 Thread() - 使用无参的方式创建对象。 Thread(String name) - 使用参数指定的名称来创建对象。 Thread(Runnable target) - 根据参数指定的接口来构造对象。 - 接口作为方法的形参时，实参传递的方式有两种： a.创建实现类的对象作为实参传递； b.使用匿名内部类来得到接口的引用作为实参传递。 Thread(Runnable target, String name) - 根据接口引用和名称共同创建对象。 void run() - 若使用Runnable对象构造的线程对象，则调用该方法最终为调用 Runnable对象中的run()方法，否则该方法不执行任何操作。 void start() - 用于启动线程，并自动调用该线程对象的run()方法。 实现原理(尽量理解)main()方法是程序的入口，执行main()方法的线程叫做主线程；由start()方法启动的线程叫做新/子线程。对于start()方法之前的代码来说，由主线程执行一次，当start()方法调用成功后，线程的个数瞬间由1个变成了2个，其中新创建的线程去执行run()方法的代码，主线程继续向下执行，两个线程各自独立运行。当run()方法结束后子线程结束，当main()方法结束后主线程结束，两个线程的执行先后次序没有明确的规定，由系统的调度算法来决定。 注意：继承的方式创建和启动线程的代码简单，但Java支持单继承，不利于项目的维护和扩展，因此在以后的开发中推荐使用实现接口的方式创建和启动线程。 思考：采用匿名内部类的方式来创建和启动一个线程呢？？解析：父类/接口类型 引用变量名 = new 父类/接口类型(){ 方法的重写; }; 线程的编号和名称(熟悉)long getId() - 用于获取线程的标识符/编号并返回。 String getName() - 用于获取线程的名称并返回。 void setName(String name) - 用于将线程名称修改为参数指定的数值。 static Thread currentThread() - 用于返回当前正在执行线程对象的引用。 线程的主要状态(了解) 使用new关键字创建线程对象后进入的状态。 此时该线程并没有开始执行。就绪状态 - 调用start()方法后进入的状态。 此时该线程仍然没有开始执行。运行状态 - 使用线程调度器调用就绪状态的线程后进入的状态。 此时该线程开始执行。 当时间片结束后线程的任务没有完成则回到就绪状态。消亡状态 - 当时间片结束后线程的任务已经完成后进入的状态。阻塞状态 - 当线程执行的过程中发生阻塞事件时进入的状态，如：sleep()方法。 当阻塞状态解除后进入就绪状态。 线程的常用方法(重点)static void sleep(long millis) - 用于让当前线程睡眠参数指定的毫秒数。 - 1秒 = 1000毫秒 static void sleep(long millis, int nanos) - 用于睡眠参数指定的毫秒数和纳秒数。 - 1秒 = 1000毫秒 1毫秒 = 1000微秒 1微秒 = 1000纳秒 int getPriority() - 用于获取当前线程的优先级并返回。 void setPriority(int newPriority) - 用于设置线程的优先级。 - 优先级越高表示获取到时间片的机会越多，但不一定先执行。 void join() - 用于让当前正在执行的线程等待调用join()方法的线程终止。 void join(long millis) - 用于等待参数指定的毫秒数。 void join(long millis, int nanos) - 用于等待参数指定的毫秒数+纳秒数。 boolean isDaemon() - 用于测试该线程是否为守护线程。 - 守护线程通常指后台运行为其它线程提供服务的线程，如：垃圾回收线程。 void setDaemon(boolean on) - 用于标记该线程为守护线程，必须在启动之前调用。 - 当所有非守护线程结束时，守护线程也会随之结束。 - 线程的同步机制(重点)1 基本概念当多个线程同时访问同一种共享资源时，可能会造成数据的不一致或覆盖等问题，此时就需要对多个线程进行协调，而线程之间的协调和通信就叫做线程的同步机制。 2 解决方案由程序可知，当两个线程同时进行取款操作后，最终的账户余额与实际生活不符。解决方案：将线程的并发操作修改为线程的串行操作。引发问题：串行操作的效率比较低，因此以后的开发中尽量不要使用。 3 实现方式在Java语言使用synchronized关键字来实现对象锁机制，从而保证线程操作的原子性，具体实现方式有两种： a.使用同步语句块的方式实现，具体语法格式如下： synchronized(对象的引用){ 编写所有需要锁定的代码块; } b.使用同步方法的方式实现，也就是使用synchronized关键字修饰整个方法即可。 该方式等价于： synchronized(this){ 所有的方法体; } 4 实现原理(尽量理解)当多个线程同时启动后各自独立运行去抢占共享资源，若其中一个线程抢到了共享资源，则其他线程进入阻塞状态，直到该线程执行完毕所有锁定代码后自动释放对象锁，此时阻塞的线程又可以抢占共享资源，抢到资源的线程继续加锁去执行，抢不到资源的线程继续阻塞。以后的开发中应当尽量减少同步的范围，从而提高多个线程并发执行的效率。 死锁(尽量理解)线程一执行的代码： public void run(){ synchronized(a){ //持有对象锁a，等待对象锁b synchronized(b){ } } } 线程二执行的代码： public void run(){ synchronized(b){ //持有对象锁b，等待对象锁a synchronized(a){ } } } 注意：在以后的开发中尽量不要使用同步语句块的嵌套结构！ Object类中的常用方法(尽量理解)void wait() - 用于使得当前线程进入等待状态，直到其它线程调用notify() 或notifyAll()方法为止。 void wait(long timeout) - 使得当前线程进入等待状态，直到其它线程调用上述方法， 或者参数指定的毫秒数已经过去为止。 void notify() - 用于唤醒单个等待的线程。 void notifyAll() - 用于唤醒所有等待的线程。 线程池 网络编程 七层协议模型(了解)ISO将数据的传递从逻辑上划分为七层来保证数据传递的可靠性和安全性等，具体如下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。当发送数据时，需要按照上述七层模型从左向右依次进行加包处理，然后再发送出去。当接收数据时，需要按照上述七层模型从右向左依次进行拆包处理，然后再解析数据。 常见的网络协议(了解)http - 超文本传输协议，主要用于浏览网页时使用。ftp - 文件传输协议，主要用于上传和下载文件时使用。tcp - 传输控制协议，主要用于网络通信时使用。udp - 用户数据报协议，主要用于网络通信时使用。ip - 互联网协议，是互联网中的底层协议。… … 协议 - 本质上就是一种规则/约定，约束了双方进行通信的方式。 IP地址(重点)如： 192.168.1.1 - 是绝大多数路由器的登录地址，进行Mac地址的绑定。 IP地址 - 是设备在互联网中的唯一地址标识。IP地址本质上是由32位二进制组成的整数，叫做IPV4，当然也有128位二进制组成的整数，叫做IPV6，目前主流的还是IPV4。为了便于现实生活中的使用，采用点分十进制表示法来进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的整数之间采用小数点分隔。 如： 0x01020304(十六进制) =&gt; 1.2.3.4 查看IP地址的方式： Windows系统：在dos窗口中使用命令ipconfig或ipconfig/all查看 Linux系统： 在终端窗口中使用命令ifconfig或/sbin/ifconfig查看 端口号(重点)IP地址 - 可以定位到具体某一台设备。端口号 - 可以定位到该设备中的具体某个进程。网络编程需要提供：IP地址 + 端口号。 端口号本质上是由16位二进制组成的整数，范围是：0 ~ 65535，其中0 ~ 1024之间的端口号通常被系统占用，以后的编程从1025开始使用。 基于tcp协议的编程模型(重点)编程模型服务器： (1)创建ServerSocket类型的对象，并提供端口号; (2)等待客户端的连接请求，调用accept()方法; (3)使用输入输出流进行通信; (4)关闭Socket并释放有关的资源; 客户端： (1)创建Socket类型的对象，并提供服务器的IP地址和端口号; (2)使用输入输出流进行通信; (3)关闭Socket并释放有关的资源; 相关类和方法ServerSocket类 java.net.ServerSocket类用于描述服务器的套接字(大插排)。 ServerSocket(int port) - 根据参数指定的端口号来创建对象。 Socket accept() - 用于监听并接受客户端的连接请求。 void close() socket类 java.net.Socket类用于描述客户端套接字(小插排)，该套接字是两台设备间通信的端点。 Socket(String host, int port) - 根据参数指定的IP地址和端口号来创建对象并建立连接 InputStream getInputStream() - 用于获取当前套接字的输入流并返回。 OutputStream getOutputStream() - 用于获取当前套接字的输出流并返回。 void close() tcp协议和udp协议的比较(笔试题)tcp协议 传输控制协议，是一种面向连接的协议，类似于打电话。 建立连接 =&gt; 进行通信 =&gt; 断开连接 在整个通信的过程中全程保持连接 保证了数据传输的可靠性和有序性 是一种全双工的字节流通信方式 服务器压力比较大，资源消耗比较多，并且发送数据的效率相对比较低 udp协议 用户数据报协议，是一种非面向连接的协议，类似于写信。 在通信的整个过程中不需要保持连接 不保证数据传输的可靠性和有序性 是一种全双工的数据报通信方式 服务器压力比较小，资源消耗比较少，并且发送数据的效率相对比较高。基于udp协议的编程模型 基于UDP协议的编程模型主机A(接收方): (1)创建DatagramSocket类型的对象，并提供端口号； (2)创建DatagramPacket类型的对象，并指定缓冲区和缓冲区的大小； (3)从Socket中接收数据放入Packet中，调用receive()方法； (4)关闭Socket并释放有关的资源； 主机B(发送方): (1)创建DatagramSocket类型的对象； (2)创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号； (3)将Packet发送到Socket中，调用send()方法； (4)关闭Socket并释放有关的资源； DatagramSocket类java.net.DatagramSocket类用于描述发送或接受数据报的套接字； DatagramSocket() - 使用无参方式构造对象； DatagramSocket(int port) - 根据参数指定的端口号来构造对象； void receive(DatagramPacket p) - 用于接收数据并存放到参数指定的对象中； void send(DatagramPacket p) - 用于将参数指定对象的内容发送出去； void close() DatagramPacket类java.net.DatagramPacket类用于描述数据报信息； DatagramPacket(byte[] buf, int length) - 构造对象用于接收数据； DatagramPacket(byte[] buf, int length, InetAddress address, int port) - 构造对象用于发送数据，并指定接收方信息； InetAddress getAddress() - 用于获取接收方或发送方的通信地址； int getPort() - 用于获取接收方或发送方的端口信息； int getLength() - 用于获取数据的长度； InetAddress类java.net.InetAddress类用于描述通信地址； static InetAddress getLocalHost() - 用于获取当前主机的通信地址； static InetAddress getByName(String host) - 用于获取参数指定主机名的通信地址； String getHostName() - 用于获取通信地址中的主机名信息； String getHostAddress() - 用于获取通信地址中的IP地址信息； 反射机制 如： Person p = new Person(); - 表示声明Person类型的引用指向Person类型的对象 p.show(); - 表示使用引用p调用show()方法 概念通常情况下，编写的代码都是固定的，此时在运行阶段只能创建指定的对象和调用指定的方法，若希望在编译阶段不确定创建什么类型的对象以及调用什么样的方法，通过运行阶段传入的参数来确定，这种机制叫做动态编程/反射机制。反射机制就是用于实现动态创建对象和动态调用方法的技术，目前主流的框架技术底层原理都是使用反射机制。 Class类基本概念java.lang.Class类的实例主要用于描述Java应用程序中的类和接口，也就是说该类的实例不再是表示堆区的一块空间，而是表示一种数据类型。该类没有公共构造方法，该类的所有对象由Java虚拟机和类加载器自动构造。 获取Class对象的主要方式a.使用数据类型.class的方式可以获取该类型的Class对象； b.使用对象.getClass()的方式可以获取该类型的Class对象； c.使用包装类.TYPE的方式可以获取对应基本数据类型的Class对象； d.使用Class.forName()的方式可以获取指定类型的Class对象； ####常用的方法 #### static Class&lt;?&gt; forName(String className) - 用于获取参数指定类型的Class对象并返回； T newInstance() - 用于创建此Class对象所表示的类对应的新实例； 如： Class c1 = Class.forName(&quot;xdl.day21.Person&quot;); c1.newInstance(); =&gt; new Person(); Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) - 用于获取当前Class对象所表示类中参数指定的单个公共构造方法并返回。 Constructor&lt;?&gt;[] getConstructors() - 用于获取当前Class对象所表示类中所有公共构造方法并返回。 如： Constructor ct1 = c1.getConstructor(String.class, int.class); =&gt; 相当于获取Person类中参数为String类型和int类型的构造方法 =&gt; 也就是获取Person类中的有参构造并返回 Field getDeclaredField(String name) - 用于获取当前Class对象所表示类中参数指定的单个成员变量并返回。 Field[] getDeclaredFields() - 用于获取当前Class对象所表示类中所有的成员变量并返回。 如： Field f1 = c1.getDeclaredField(&quot;name&quot;); =&gt; 相当于获取Person类中名字为name的成员变量并返回。 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) - 用于获取当前Class对象所表示类中参数指定的单个公共成员方法并返回。 Method[] getMethods() - 用于获取当前Class对象所表示类中所有的公共成员方法并返回。 如： Method m1 = c1.getMethod(&quot;getName&quot;); =&gt; 相当于获取Person类中名字为getName的成员方法并返回。 Constructor类基本概念java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息。 常用的方法 T newInstance(Object... initargs) - 使用调用对象所表示的构造方法来创建新实例，并使用参数来初始化该实例。 如： Object obj = ct1.newInstance(&quot;zhangfei&quot;, 30); =&gt; new Person(&quot;zhangfei&quot;, 30); Field类基本概念java.lang.reflect.Field类用于描述获取到的单个成员变量信息。 常用的方法 Object get(Object obj) - 用于返回指定对象obj中当前调用对象所表示成员变量的数值 如： f1.get(obj); =&gt; 相当于获取对象obj中名字为name成员变量的数值并返回。 =&gt; 返回obj.name的效果，也就是返回zhangfei。 void set(Object obj, Object value) - 用于将对象obj中当前调用对象所表示成员变量的数值修改为value。 如： f1.set(obj, &quot;guanyu&quot;); =&gt; 相当于将对象obj中名字为name成员变量的数值修改为guanyu。 =&gt; 将zhangfei改为guanyu。 void setAccessible(boolean flag) - 当实参为true时表示取消Java语言的访问检查。 Method类基本概念java.lang.reflect.Method类用于描述获取到的单个成员方法。 常用的方法 Object invoke(Object obj, Object... args) - 使用对象obj来调用当前调用对象所表示的成员方法，其中args为该方法的实参。 如： m1.invoke(obj); =&gt; 相当于使用对象obj来调用getName()成员方法。 =&gt; 相当于obj.getName() 设计原则 项目开发的流程需求分析文档 =&gt; 概要设计文档 =&gt; 详细设计文档 =&gt; 编码和测试 =&gt; 安装和调试 =&gt; 维护和升级 常用的设计原则开闭原则 对扩展开放，对修改关闭 任何软件都是有bug的，bug就是臭虫、漏洞的意思 提高了项目的可维护性和可扩展性。 如： public class Person{ private String name; private int age; ... ... } public class Student extends Person{ private int id; ... ... } 里氏代换原则 任何父类可以出现的地方子类一定可以出现 子类 is a 父类。 建议多使用继承和多态的方式编码。 如： public static void draw(Shape s){ s.show(); } draw(new Rect(1, 2, 3, 4)); draw(new Circle(5, 6, 7)); 依赖倒转原则 尽量多依赖抽象类和接口，而不是具体实现类 抽象类和接口对子类具有强制性和规范性。 如： public abstract class A{ public abstract void show(); } public class B extends A{ public void show(){} } 接口隔离原则 尽量多依赖于小接口而不是大接口，避免接口的污染 如： public interface FlyAnimal{ public abstract void fly(); } public interface RunAnimal{ public abstract void run(); } class Dog implements RunAnimal{ ... ... } 迪米特法则（最少知道原则） 一个实体应当尽量少与其它实体之间发生关联 高内聚低耦合 内聚就是指一个实体应当将该有的所有功能聚集于该实体的内部。 耦合就是指一个实体与其它实体之间的关联度。 合成复用原则 尽量多使用合成的方式而不是继承 如： class A{ void show(){} } class B extends A{ void test(){ show(); } } class A{ void show(){} } class B{ private A a; void test(){ a.show(); } } 设计模式基本概念设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式本质上就是一种固定的套路，使用在固定的场合中。 ###基本分类 ### 创建型模式 - 工厂方法模式、抽象工厂模式、单例设计模式。(要求会写) 结构型模式 - 装饰器模式、代理模式。(要求看懂) 行为型模式 - 模板设计模式、观察者模式。(以后讲到) 常用的算法常用的查找算法(重点)线性查找算法(顺序查找算法)算法流程 a.使用目标元素与样本数列中的第一个元素起依次进行比较； b.若找到与目标元素相等的元素，则表示查找成功； c.若目标元素与所有样本元素比较完毕都没有找到相等的元素，则表示查找失败； 二分查找算法(折半查找算法)算法流程 a.假定样本数列从小到大排列，使用目标元素与样本数列中的中间元素比较大小； b.若目标元素与中间元素相等，则表示查找成功； c.若目标元素小于中间元素，则应该去中间元素的左边进行查找，重复步骤b； d.若目标元素大于中间元素，则应该去中间元素的右边进行查找，重复步骤b； e.直到目标元素与所有该比较的元素比较完毕也不相等，则表示查找失败； 常用的排序算法冒泡排序算法(重中之重)算法流程 a.比较相邻位置两个元素的大小，若第一个元素比第二个元素大，则交换两个元素的位置； b.从开始的第一对元素一直到结尾的最后一对，使用步骤1依次比较，经过这一轮，最后的 元素将是这组元素中的最大值； c.重复步骤b，持续对越来越少的元素进行比较，直到处理完毕所有元素为止； (当任意两个相邻位置的元素都不需要发生交换时，证明排序完毕) 插入排序算法(理解思想)算法流程 a.从第一个元素起，认定该元素已经有序； b.取出下一个元素，让取出的元素与左边的有序数列从右向左依次比较大小； c.若取出的元素小于左边的元素，则将左边的元素右移，也就是赋值到下一个位置； d.若取出的元素大于等于左边的元素，则将取出的元素插入到左边元素的右边； e.重复步骤b，直到处理完毕所有元素为止； 选择排序算法(理解思想)算法流程 a.取出第一个元素，并假定该元素为这组元素中的最小值，使用变量min记录下标； b.使用min记录的最小值与后续元素依次比较大小； c.若后续元素中出现了比min记录的最小值还小的元素，则使用min重新记录该元素； d.直到min记录的最小值与后续所有元素比较完毕时，交换min记录的最小值与最开始 假定的最小值，经过这一步，这组元素中的最小值便放在了最起始位置； e.重复步骤a，直到处理完毕所有元素为止； 快速排序算法(重点)算法流程 a.使用样本数列中的中间元素作为基准值并单独保存； b.分别使用左右两边的元素依次与基准值比较大小，将所有比基准值小的元素放在基准值 的左边，将所有大于等于基准值的元素放到基准值的右边，这个过程叫做分组； c.直到左右两边的元素下标重合时，将基准值放到重合的位置，此时分组完成； d.分别对基准值左右两边的分组重复以上过程进行再次分组，直到处理完毕所有元素为止； SE阶段代表性编程题1.打印九九乘法表（双重for循环） 2.个人所得税（if else if 分支结构） 3.数组的增删改查 4.递归方法的调用 5.单例设计模式（饿汉式，懒汉式） 6.匿名内部类 7.自定义异常类 8.递归实现多层文件读取文件名 9.使用byte[] 实现文件的拷贝 10.多线程的实现方式（扩展） 11.基于TCP协议的网络编程（UDP协议 扩展） 12.冒泡算法(快速算法 扩展) 13.工厂模式 抽象工程模式(23种设计模式 扩展) 14.学生信息管理系统]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Java笔记三核心类库二]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Java%E7%AC%94%E8%AE%B0%E4%B8%89%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[集合类 数组和集合的比较数组的特点: 本质上就是一段连续的存储空间，用于记录多个类型相同的数据。 支持下标访问，可以实现随机访问。 数组一旦定义则长度固定，无法自动调整内存空间的大小。 增删元素不方便，可能会造成大量元素的移动。 数组元素可以是基本数据类型，也可以是引用数据类型。 集合的特点: 内存空间可以连续也可以不连续，数据类型可以不相同。 部分支持下标访问，部分不支持。 集合的存储空间长度不固定，可以随时自动调整大小。 增删元素方便，可以不移动任何元素。 集合元素必须是引用数据类型。 集合框架 在Java中集合框架的顶层接口是：java.util.Collection接口 和 java.util.Map接口。其中Collection接口中操作元素的基本单位是：单个元素。其中Map接口中操作元素的基本单位是：单对元素。在以后的开发中Collection接口本身很少使用，更多的是该接口的子接口：List接口、Queue接口、Set接口。 Collection接口的常用方法boolean add(E e) - 用于将参数指定的元素e放入当前集合中。 - 若当前集合发生改变则返回true，否则返回false。 boolean addAll(Collection&lt;? extends E&gt; c) - 用于将参数指定集合c中的所有元素放入当前集合中。 boolean remove(Object o) - 用于从当前集合中移除参数o指定的单个元素。 boolean removeAll(Collection&lt;?&gt; c) - 用于从当前集合中移除参数c指定的所有元素。 void clear() - 用于移除当前集合中的所有元素，也就是清空当前集合。 boolean contains(Object o) - 用于判断当前集合中是否包含参数指定的单个元素。 boolean containsAll(Collection&lt;?&gt; c) - 用于判断当前集合中是否包含参数指定的所有元素。 int size() - 用于获取当前集合中的元素个数并返回。 boolean isEmpty() - 判断当前集合是否为空。 boolean retainAll(Collection&lt;?&gt; c) - 用于计算当前集合和参数集合中的交集并保留到当前集合中。 - 若当前集合中的元素发生改变则返回true，否则返回false。 List集合 基本概念 java.util.List接口是Collection接口的子接口，元素有放入先后次序，并且允许重复。 该接口的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类 其中ArrayList类的底层是采用动态数组实现的，因此访问元素方便，增删元素不方便。 其中LinkedList类的底层是采用双向链表实现的，因此访问元素不方便，增删元素方便。 其中Stack类的底层是采用动态数组实现的，该类主要描述具有后进先出特性的数据结构，简称为LIFO(last in first out 栈)。 其中Vector类的底层是采用动态数组实现的，与ArrayList类相比，是Java早期提供的类，属于线程安全的类，因此效率比较低，推荐使用ArrayList类取代之。 常用的方法void add(int index, E element) - 用于将元素element插入到当前集合中index的位置。 boolean addAll(int index, Collection&lt;? extends E&gt; c) - 用于将集合c中的所有元素插入到当前集合中index的位置。 E remove(int index) - 用于删除当前集合中下标为index位置的元素并返回。 E set(int index, E element) - 用于将当前集合中index位置的元素替换为element并返回之前的元素值。 E get(int index) - 用于获取当前集合中index位置的元素并返回。 List&lt;E&gt; subList(int fromIndex, int toIndex) - 用于获取当前集合中从fromIndex(含)到toIndex(不含)之间的部分视图并返回。 - 所谓视图就是并没有申请新的内存空间去单独存放可以看到的元素。 泛型机制 通常情况下，集合中允许存放不同类型的数据内容，是因为这些数据全部被看做Object类型放入的，当需要从集合中取出元素时则也只能按照Object类型来处理，若希望表达该元素真实的数据类型时，就需要进行强制类型转换，而该方法容易引发类型转换异常。为了避免上述错误的发生，从jdk1.5开始引入泛型机制，也就是在每个集合类型的右侧使用&lt;数据类型&gt;的方式明确要求该集合可以存放的元素类型，若放入元素类型不匹配则编译报错。 如： List&lt;String&gt; l1 = new LinkedList&lt;String&gt;(); 原理(尽量理解)：泛型的本质就是参数化类型，也就是让数据类型作为参数进行传递的过程。其中List集合中的E相当于形式参数进行占位，而使用List集合时&lt;&gt;中的数据类型相当于实际参数对形式参数进行赋值，当赋值完毕后则List集合中所有的E都会被&lt;&gt;中的类型加以替换，而实际参数的种类可以是多样的，因此导致同一个List集合却能处理各种不同类型的数据，支持更加广泛的类型，从而得名”泛型”。 Queue接口(重点)基本概念java.util.Queue接口是Collection接口的子接口，与List接口属于平级关系。该接口主要用于描述一种具有先进先出特征的数据结构，简称为FIFO(first in first out)该接口的主要实现类是：LinkedList类。 常用的方法 boolean offer(E e) - 用于将参数指定的元素e插入到当前队列中的末尾。 E poll() - 用于获取并移除当前队列中的队首元素，若队列为空，则返回null。 E peek() - 用于获取队首元素并返回，若队列为空，则返回null。 Set接口(重点)1 基本概念 java.util.Set接口是Collection接口的子接口，元素没有放入次序并且不允许重复。该接口的主要实现类有：HashSet类 和 TreeSet类。其中HashSet类的底层是采用哈希表进行数据的管理。其中TreeSet类的底层是采用二叉树进行数据的管理。 常用的方法参考Collection集合的方法即可。 Iterator&lt;E&gt; iterator() - 用于获取当前集合的迭代器对象，可以访问集合中的每个元素 boolean hasNext() - 用于判断当前集合中是否拥有元素可以迭代/遍历/访问。 E next() - 用于获取一个元素并指向下一个位置。 void remove() - 用于从集合中移除刚刚获取到的元素。 注意： 当迭代集合中的所有元素时，若希望删除某个元素则需要使用迭代器自己的remove()方法，若使用集合的remove()方法则会引发并发修改异常。 增强版的for循环(for each)(1)语法格式 for(元素类型 变量名 : 数组名/集合名){ 循环体; } (2)执行流程 不断地从数组/集合中取出元素并赋值给变量名，然后执行循环体，直到处理完毕所有元素 总结： 对于Set集合来说，遍历所有元素的方式有3种：toString()、迭代器、增强版for循环。 对于List集合来说，遍历方式除了上述3种之外，还有 get()方法的获取。 TreeSet类什么是二叉树？二叉树就是指每个节点最多只有两个子节点的树形结构。 什么是有序二叉树？有序二叉树就是指满足以下3个条件的二叉树，又叫做二叉查找树。 要求左子树中任意节点的元素值都小于根节点元素值； 要求右子树中任意节点的元素值都大于根节点元素值； 左子树和右子树的内部也要遵循上述规则；向TreeSet类中放入元素当需要添加元素到TreeSet集合时，需要指定元素比较大小的规则，具体方式如下：a.使用元素的自然排序进行处理，也就是让元素类型实现java.lang.Comparable接口；b.使用比较器进行处理，也就是创建TreeSet对象时传入java.util.Comparator接口； 注意：当创建TreeSet集合时没有传入比较器则采用元素的自然排序规则进行处理，若传入比较器则按照比较器的规则进行处理，并且使用比较器可以实现多元化的排序。 Map接口(重点)1 基本概念java.util.Map&lt;K,V&gt;接口中操作元素的基本单位是：单对元素，具体格式如下：K - 此映射所维护的键(Key)的类型V - 映射值(Value)的类型该接口中不能包含重复的key，并且一个key最多只能对应一个value。该接口的主要实现类为：HashMap类 和 TreeMap类。 2 常用的方法 V put(K key, V value) - 使用参数指定的key和value组成一对放入当前集合中。 - 若当前集合中没有key则返回null，否则返回key之前对应的value. V remove(Object key) - 用于从当前集合中移除参数key指定的元素。 boolean containsKey(Object key) - 用于判断当前集合是否包含参数指定的key. boolean containsValue(Object value) - 用于判断当前集合是否包含参数指定的value. V get(Object key) - 用于根据参数指定的key返回对应的value。 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() - 用于将当前调用对象表示的Map集合转换为Set集合并返回。 K getKey() - 用于获取Entry类型变量中的key并返回。 V getValue() - 用于获取Entry类型变量中的value并返回。 Set&lt;K&gt; keySet() - 用于将当前调用对象表示的Map集合中所有的Key组成Set集合并返回。 HashMapHashMap原理: HashMap性能: 异常机制 File类(重点)基本概念java.io.File类用于描述指定路径信息的文件或目录，可以获取相关的属性信息，大小等 常用的方法 File(String pathname) - 根据参数指定的路径名来构造对象进行关联。 boolean exists() - 用于判断文件或目录是否存在。 String getName() - 用于获取文件或目录的名称。 long length() - 用于获取文件的长度/大小。 long lastModified() - 用于获取文件的最后一次修改时间，需要与Date类搭配使用。 String getAbsolutePath() - 用于获取绝对路径信息并返回。 绝对路径 - 主要指以根目录开始的路径信息，如：C:/.. D:/... /... 相对路径 - 主要指以当前所在目录开始的路径信息，如：./... - 以后的开发中推荐使用相对路径的方式。 boolean delete() - 用于删除文件或目录。 boolean createNewFile() - 用于创建新的空文件。 boolean mkdir() - 用于创建单层目录。 boolean mkdirs() - 用于创建多层目录。 File[] listFiles() - 用于获取当前目录中的所有内容并返回。 boolean isFile() - 用于判断是否为标准文件。 boolean isDirectory() - 用于判断是否为目录文件。 I/O流基本概念 I/O就是Input/Output的简写，也就是表示输入/输出的含义。I/O流就是指像流水一样不间断地进行数据的读写过程。 基本分类 以读写数据的单位不同分为：字节流和字符流。其中字节流就是指以字节为单位进行读写的流，可以读写任意类型的文件。其中字符流就是指以字符(2个字节)为单位进行读写的流，只能读写文本文件。 以数据流动的方向不同分为：输入流和输出流(站在程序的角度)。其中输入流就是指将数据内容输入到程序中的流，也就是读文件。其中输出流就是指将数据内容从程序中输出，也就是写文件。 基本框架 FileOutputStream类(重中之重) 基本概念java.io.FileOutputStream类用于将图像数据之类的原始字节流写入到输出流中。 常用的方法 FileOutputStream(String name) - 根据参数指定的路径名来构造对象。 FileOutputStream(String name, boolean append) - 用于以追加的方式构造对象。 void write(int b) - 用于将参数指定的单个字节写入输出流。 void write(byte[] b, int off, int len) - 用于将数组b中从off位置开始的len个字节写入输出流。 void write(byte[] b) - 用于将数组b中的所有字节写入输出流。 void close() - 用于关闭流对象并释放有关的资源。 FileInputStream类(重中之重)基本概念java.io.FileInputStream类用于读取图像数据之类的原始字节流。 常用的方法 FileInputStream(String name) - 根据参数指定的文件名来构造对象。 int read() - 用于从输入流中读取一个字节的数据并返回，若读到文件末尾则返回-1。 int read(byte[] b, int off, int len) - 用于从输入流中读取len个字节放入数组b中下标为off的位置上。 - 成功返回实际读取到的字节数，若读到文件末尾则返回-1。 int read(byte[] b) - 用于从输入流中读取b.length个字节放入数组b中。 int available() - 用于获取此输入流所关联文件的大小。 void close() - 用于关闭流对象并释放有关的资源。 DataOutputStream类(熟悉)基本概念java.io.DataOutputStream类主要用于将Java语言中基本数据类型的内容写入输出流中。 常用的方法 DataOutputStream(OutputStream out) - 根据参数指定的引用来构造对象。 - 其中OutputStream类是个抽象类，实参需要传递子类的对象。 void writeInt(int v) - 用于将参数指定的整数以4个字节的形式写入输出流中。 - 优先写入高字节数据，如：12: 0000 0000 0000 0000 0000 0000 0000 1100 void close() DataInputStream类(熟悉)基本概念java.io.DataInputStream类用于从输入流中读取Java基本数据类型的内容。 常用的方法 DataInputStream(InputStream in) - 根据参数指定的引用来构造对象。 - 其中InputStream类是个抽象类，实参需要传递子类的对象。 int readInt() - 用于读取一个整数并返回。 void close() BufferedWriter类(重点)基本概念java.io.BufferedWriter类用于写入单个字符、字符数组以及整个字符串到输出流中。 常用的方法 BufferedWriter(Writer out) - 根据参数指定的引用来构造对象。 - 其中Writer类是个抽象类，因此实参需要传递子类的对象。 void write(int c) - 用于写入参数指定的单个字符。 void write(char[] cbuf, int off, int len) - 用于将参数cbuf中下标从off位置开始的len个字符写入输出流。 void write(char[] cbuf) - 用于将参数cbuf中整个字符数组的内容写入输出流。 void write(String s, int off, int len) - 用于将参数s中从off位置开始的len个字符写入输出流中。 void write(String str) - 用于将参数str指向的整个字符串写入输出流中。 void newLine() - 用于写入一个行分隔符。 void close() BufferedReader类(重点)基本概念java.io.BufferedReader类用于从输入流中读取单个字符、字符数组以及一行字符串内容。 常用的方法 BufferedReader(Reader in) - 根据参数指定的引用来构造对象。 - 其中Reader类是个抽象类，实参需要传递子类的对象。 int read() - 用于读取单个字符并返回。 int read(char[] cbuf, int off, int len) - 用于读取len个字符放入字符数组cbuf中下标从off开始的位置。 int read(char[] cbuf) - 用于读取cbuf.length个字符放入字符数组中。 String readLine() - 用于读取一行字符串并返回。 void close() PrintStream类(重点)基本概念java.io.PrintStream类用于实现各种数据格式的打印/输出。 常用的方法 PrintStream(OutputStream out) - 根据参数指定的引用来构造对象。 - 其中OutputStream类是个抽象类，实参需要传递子类的对象。 void print(String s) - 用于输出参数指定的字符串。 void println(String x) - 用于输出字符串后换行。 void close() ObjectOutputStream类(重点) 基本概念java.io.ObjectOutputStream类主要用于将Java语言中的对象整体写入输出流中。只能将支持 java.io.Serializable 接口的对象写入流中类通过实现 java.io.Serializable 接口以启用其序列化功能。序列化就是指将一个对象的相关信息有效组织成一个字节序列的过程，反之就叫做反序列化 常用的方法 ObjectOutputStream(OutputStream out) - 根据参数指定的引用构造对象。 - 其中OutputStream类是个抽象类，实参需要传递子类的对象。 void writeObject(Object obj) - 用于将参数指定的对象整体写入输出流。 void close() ObjectIntputStream类(重点)基本概念java.io.ObjectInputStream类用于将之前写入的对象整体读取出来。 常用的方法 ObjectInputStream(InputStream in) - 根据参数指定引用来构造对象。 - 其中InputStream类是抽象类，实参传递子类的对象。 Object readObject() - 用于读取一个对象并返回。 void close() 经验的分享：当需要将多个对象写入文件时，通常建议将多个对象放入一个集合中，然后将这个集合看做一个对象整体写入文件中，此时只需要写入一次，而读取文件中的内容时，可以一次性将整个集合读取出来。]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Java笔记二SE面向对象]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Java%E7%AC%94%E8%AE%B0%E4%BA%8CSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象 面向对象编程 1 什么是对象？ 万物皆对象。 2 什么是面向对象？ 面向对象就是指以特征/属性和行为的观点去分析现实世界中事物的方式。 3 什么是面向对象编程？ 面向对象编程就是指先以面向对象的方式进行分析，然后采用一门面向对象的编程语言进行翻译的过程。 其中C语言是一门面向过程的编程语言; 其中C++语言是一门既面向过程又面向对象的编程语言； 其中Java语言是一门纯面向对象的编程语言； 4 为什么需要面向对象编程？ 面向对象编程是软件产业化和规模化发展的需求。 5 如何学好面向对象编程？ 深刻理解和琢磨面向对象编程的三大特性：封装、继承、多态。 Java类如： String name1 = &quot;张三&quot;; ... String name2 = &quot;李四&quot;; ... String name3 = &quot;王五&quot;; ... String name4 = &quot;赵六&quot;; ... ... ... 人类： 特性：姓名、年龄 行为：吃饭、学习 基本概念对象是现实生活中的实体，在Java语言中本质上就是内存中的一块存储空间。类简单来说就是”分类”，是多个对象共性提取的抽象描述，在Java中是一种引用数据类型，里面包含了描述特征的成员变量，以及描述行为的成员方法。 类的定义(1)类定义的语法格式 class 类名{ 类体; } 如： class Person{ } 注意: 一般来说，当类名由多个单词组成时，要求每个单词的首字母都要大写。 (2)成员变量定义的语法格式 class 类名{ 数据类型 成员变量名 = 初始值; - 其中=初始值通常省略不写 } 如： class Person{ String name; int age; } 注意： 一般来说，当成员变量名由多个单词组成时，要求从第二个单词起首字母大写。 对象的创建 (1)语法格式 new 类名(); 如： new Person(); - 表示创建一个Person类型的对象 (2)使用方式 当定义类之后可以使用上述语法格式进行对象的创建/构造，这个过程叫做类的实例化，本质上会在堆区申请一块空间用于存放该对象独有的特征信息。 对象创建的过程 1 单个对象创建的执行过程 main()方法是程序的入口，当创建对象时会在堆区申请内存空间； 没有指定成员变量的初始值时，则采用默认初始化进行； 当显式指定成员变量的初始值时，则先默认初始化再显式初始化； 执行构造块中的代码，可以对成员变量的数值进行更改； 执行构造方法体中的代码，可以对成员变量的数值进行更改； 此时对象创建完毕，继续执行后续的代码； 2 子类对象创建的执行过程 main()方法是程序的入口，当创建子类对象时会在堆区申请内存空间； 先加载父类再加载子类，因此先执行父类的静态语句块，再执行子类的静态语句块； 先构造父类部分再构造子类部分，因此执行父类的构造块，执行父类的构造方法体； 执行子类的构造块，执行子类的构造方法体； 此时对象构造完毕，继续执行后续的代码； 引用(1)基本概念 在Java中使用引用数据类型声明的变量叫做引用型变量，简称为&quot;引用&quot;。 (2)语法格式 类名 引用变量名; 如： Person p; - 声明一个Person类型的引用p (3)使用方式 声明引用变量可以记录对象在堆区中的地址信息，从而可以访问对象中的特征信息，具体方式如下： 引用名.成员变量名; 如： Person p = new Person(); p.name = &quot;zhangfei&quot;; System.out.println(p.name); 成员方法1 语法格式 class 类名{ 返回值类型 成员方法名称(形参列表){ 方法体; } } 如： class Person{ void eat(){ System.out.println(&quot;蛋炒饭真好吃！&quot;); } } 注意： 一般来说，当成员方法名称由多个单词组成时，要求从第二个单词起首字母大写。 2 方法的详解 (1)返回值类型 返回值主要指从方法体内向方法体外返回的数据内容。返回值类型就是指返回值的数据类型，可以是基本数据类型，也可以是引用数据类型。 如： 当方法体中返回的数据内容是66时，则返回值类型写int即可； 当方法体中返回的数据内容是3.14时，则返回值类型写double即可； 当方法体中返回的数据内容是&quot;hello&quot;时，则返回值类型写String即可； 在方法体中使用return关键字负责返回数据内容，并结束当前方法。 如： 当返回的数据内容是66时，则方法体中写：return 66; 当返回的数据内容是变量num时，则方法体中写：return num; 当方法体中没有需要返回的数据内容时，则返回值类型写void即可； (2)形参列表 形式参数主要用于将方法体外的数据内容带入方法体内进行使用，格式：数据类型 形参变量名形参列表就是指多个形参参数，语法格式：数据类型 形参变量1, 数据类型 形参变量2,… 如： 当传入的数据内容是66时，则形参列表写为：int i; 当传入的数据内容是3.14时，则形参列表写为：double d; 当传入的数据内容是&quot;hello&quot;时，则形参列表写为：String s; 当传入的数据内容是66和3.14时，则形参列表写为：int i, double d; 当传入的数据内容是66和&quot;hello&quot;时，则形参列表写为：int i, String s; 当不需要向方法体内传入任何数据时，则形参列表位置啥也不写即可； (3)方法体方法体主要用于描述该方法的功能，因此编写所有与功能有关的语句块； 方法的调用(1)语法格式 引用.成员方法名(实参列表); 如： p.eat(); (2)使用方式 实际参数列表主要用于对形式参数列表进行赋值操作，因此实参列表和形参列表的个数、类型以及先后顺序等必须保持一致。 实际参数可以传递 直接量、变量、表达式、方法的调用等； 构造方法及方法重载1 构造方法 如： Person p = new Person(); - 表示声明Person类型的引用指向Person类型的对象 p.show(); - 表示调用Person类中名字为show()的方法 (1)语法格式 class 类名{ 类名(形参列表){ 构造方法体; } } 如： class Person{ Person(){ System.out.println(&quot;构造方法我来了！&quot;); } } (2)注意事项 a.构造方法的名称与类名完全相同； b.构造方法没有返回值类型，连void都不能写； c.构造方法用于在创建对象时被自动调用，从而实现该对象成员变量的初始化工作； (3)默认构造方法 当一个类中没有提供任何形式的构造方法时，编译器会自动生成一个无参的空构造方法，叫做默认/缺省构造方法，如：Person(){}。 若类中提供了自定义的构造方法，则编译器不再提供任何形式的构造方法。 2 方法的重载(重点) (1)基本概念 在Java语言中，允许出现方法名相同、参数列表不同的多个方法存在，这些方法之间构成重载关系(Overload)。 (2)主要形式 方法重载的主要形式体现在：形参个数不同、形参类型不同、形参顺序不同，与形参变量名无关，与返回值类型无关，但建议返回值类型最好相同。 判断方法能否构成重载的核心：判断调用该方法时能否加以区分。 (3)实际意义 方法重载的实际意义就是为了让调用者使用方便，调用者只需要记住一个方法名就可以调用各种不同的版本从而实现各种不同的效果。 如： byte b1 = 10; System.out.println(b1); short s1 = 20; System.out.println(s1); int i1 = 30; System.out.println(i1); this关键字1 基本概念 对于构造方法来说，this关键字就代表当前正在构造的对象；对于成员方法来说，this关键字就代表当前正在调用的对象； 原理(尽量理解)： this关键字本质上就是构造方法和成员方法中隐含的形参变量，当不同的对象调用同一个方法时，本质上会将不同的对象作为实参传递给形参this，而在方法体中访问成员变量时，相当于this.(我的)的方式进行访问，此时this不同导致成员变量的数值随之不同。 2 使用方式 (1)当形参变量名和成员变量名同名时，在方法体中会优先选择形参变量使用，若希望明确 告诉编译器使用成员变量时，则需要在成员变量名的前面加上this.加以描述。(2)使用this(实参)的方式在构造方法的第一行可以调用其他构造方法(了解)。 方法的传参和递归调用8.1 方法的传参过程(尽量理解) (1)main()方法是程序的入口，因此先为变量a、b、res分配内存空间并初始化； (2)调用max()方法时，为max()方法的形参变量a、b分配内存空间； (3)将实参变量a、b的数值赋值给形参变量a、b； (4)执行max()方法的方法体，方法结束时会释放形参变量a、b的内存空间； (5)main()方法中的变量res得到max()方法的返回值，继续向下执行； 要求掌握的内容： a.当参数类型为基本数据类型时，此时形参数值的改变不会影响到实参数值(独立空间)； b.当参数类型为引用数据类型时，此时若修改形参变量指向的内容会影响到实参数值， 因为形参和实参指向同一块区域； c.当参数类型为引用数据类型时，此时若修改形参变量的指向后再修改内容，那么不会 影响到实参的数值，因为形参变量指向的区域与实参变量不同； 8.2 方法的递归调用(难点) 基本概念 递归就是指在方法体的内部调用该方法自身的形式。 案例： 自定义成员方法计算参数n的阶乘并返回。 解析： 5! = 5*4*3*2*1; 4! = 4*3*2*1; ... 1! = 1; 5! = 5*4!; 4! = 4*3!; 3! = 3*2!; 2! = 2*1!; 1! = 1; 使用方式 a.使用递归必须要找到规律和退出条件； b.使用递归必须使得问题简单化而不是复杂化； c.若递归影响程序的执行性能，则应该使用递推取代之； 9 类加载机制 10 JVM内存结构 GC 封装基本概念 通常情况下，在测试类中可以对成员变量进行访问，当给成员变量赋值合法但不合理的数据时，在编译阶段和运行阶段都不会报错或者给出提示，此时与现实生活不符。为了避免上述问题，就需要对成员变量进行密封包装等处理，这种机制就叫做封装，换句话说，封装就是一种保证成员变量值合理的技术。 封装的流程 私有化成员变量，使用private关键字修饰。 提供公有的get和set成员变量方法，在方法体中进行合理值的判断。 在构造方法中调用set成员变量的方法进行处理。 static关键字基本概念 通常情况下，成员变量隶属于对象层级，也就是每个对象单独保存自己独有的特征信息，当所有对象中某个特征信息完全一样时还各自记录就会造成内存空间的浪费。为了节省内存空间，此时可以使用static关键字修饰该成员变量表示静态的概念，所谓静态就是将该成员变量由对象层级提升到类层级，随着类的加载而准备就绪，与对象是否创建无关，建议使用类名.的方式来进行访问。static关键字也可以修饰成员方法。 使用方式 对于非静态的成员方法来说，既可以访问非静态的成员又可以访问静态的成员；(成员：成员变量 + 成员方法 静态成员被所有对象共享) 对于静态的成员方法来说，只能访问静态的成员不能访问非静态的成员；(成员：成员变量 + 成员方法 静态的成员在使用时可能还没有创建对象) 只有隶属于类层级被所有对象共享的内容才可以使用static修饰，不能滥用static关键字； 单例设计模式基本概念 在某些特殊场合中，一个类对外提供一个且只能提供一个对象，这样的类叫做单例类。设计单例类的思想和方式叫做 单例设计模式。 实现流程 私有化构造方法，使用private关键字修饰； 提供本类类型的引用指向本类类型的对象，并使用private static共同修饰； 提供公有的get成员变量方法，将本类的对象返回出去； 实现方式 单例设计模式主要有：饿汉式 和 懒汉式，在以后的开发中推荐使用饿汉式； /* 编程实现Singleton类的封装 */ public class Singleton{ //2.提供一个本类类型的引用指向本类自己的对象 //int cnt = 1; //private static Singleton sin = new Singleton(); //饿汉式 private static Singleton sin = null; //懒汉式 //1.私有化构造方法，使用private关键字修饰 //只能在本类的内部使用 private Singleton(){ } //3.提供一个公有的方法将sin的数值返回出去 public static Singleton getInstance(){ //return sin; if(sin == null){ sin = new Singleton(); } return sin; } } 继承 基本概念 当多个类之间有相同的特征和行为时，可以将共性的内容提取出来组成一个公共类，让这多个类分别吸收公共类中的特征和行为，而在各个类的内部只需要编写独有特征和行为的机制，叫做继承.使用继承可以提高代码的复用性和可扩展性以及可维护性。在Java语言中使用 extends 来表达继承的关系。 如： public class Student extends Person{} - 表示Student类继承自Person类 其中Person类叫做 超类/父类/基类。 其中Student类叫做 派生类/子类/孩子类。 注意事项 子类可以继承父类的成员变量和成员方法，包括私有的成员变量但不能直接使用；子类不可以继承父类的构造方法 和 私有方法。 无论使用何种形式构造子类的对象时，都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在子类构造方法的第一行增加代码：super();的效果。 Java语言支持单继承不支持多继承，也就是一个子类只能有一个父类，一个父类可以有多个子类。 使用继承必须满足以下逻辑关系： 子类 is a 父类，也就是不能滥用继承。 this和super的比较基本概念 this代表 一个本类的对象；super代表 一个父类的对象； 使用方式使用this.的方式可以访问本类的成员；使用super.的方式可以访问父类的成员； 使用this()的方式在构造方法的第一行表示调用本类中的其他构造方法；使用super()的方式在构造方法的第一行表示调用父类的构造方法； 要求掌握的用法： a.使用this.的方式区分同名的成员变量和局部变量； b.使用super(实参)的方式调用父类的构造方法； c.使用super.的方式可以调用父类中被重写的方法； 方法的重写基本概念 当父类中继承下来的方法不足以满足子类的需求时，则需要在子类中重新写一个和父类一样的方法去覆盖从父类中继承下来的方法，这种方式叫方法的重写(Override)。 基本原则 要求方法名、参数列表、返回值类型相同，从jdk1.5开始允许返回子类类型； 要求访问权限不能变小，可以相同或者变大； 要求不能抛出更大的异常(异常机制)； 访问控制 常见的访问控制符 public - 公有的 protected - 保护的 啥也不写 - 默认的 private - 私有的 访问控制符之间的比较 访问控制符 访问权限 本类 本包中的类 子类 其它包的类 public 公有的 Y Y Y Y protected 保护的 Y Y Y N 空 默认的 Y Y N N private 私有的 Y N N N 要求大家掌握的内容： public修饰的成员可以在任意位置访问； private修饰的成员只能在本类的内部访问； 通常情况下，成员变量都使用private修饰，成员方法都使用public修饰； 3 包的定义 package 包名; - 用于声明单层包 package 包名1.包名2...包名n; - 用于声明多层包，主要为了管理文件和区分同名文件 final关键字基本概念 final本意为”最终的，不可更改的”，可以修饰类、方法以及成员变量。 使用方式 使用final修饰类体现在该类不能被继承； 为了防止滥用继承，如：String类、System类等。使用final修饰方法体现在该方法不能被重写； 为了防止不经意间造成的重写，如：SimpleDateFormat类中的format()方法。使用final修饰成员变量体现在该成员变量必须被初始化而且不能更改； 为了防止不经意间造成的修改，如：Thread类的MAX_PRIORITY。 注意： 在以后的开发中static和final关键字很少单独使用，通常使用public static final共同修饰表达常量的概念，常量的命名规范是：所有字母大写，不同单词之间使用下划线连接。 如： public static final double PI = 3.14; 多态 基本概念多态就是指同一种事物表现出来的多种形态** 如: 饮料：可乐、雪碧、加多宝、乐虎、... 宠物：猫、狗、乌龟、鸟、小强、... 整数：byte b1 = 10; short s1 = 10; int i1 = 10; ... ... ... 语法格式父类类型 引用变量名 = new 子类类型(); 如： Pet p = new Cat(); p.show(); 原理： 在编译阶段p是Pet类型的引用，只能调用Pet类中的show()方法；在运行阶段p真正指向的对象是Cat类型的，因此最终调用Cat类中重写的show()方法。 多态的效果 使用父类的引用指向子类的对象时，父类的引用可以直接调用父类自己的方法； 使用父类的引用指向子类的对象时，父类的引用不可以直接调用子类独有的方法； 对于父子类都有的非静态成员方法来说，最终调用子类重写的版本； 对于父子类都有的静态成员方法来说，最终调用父类中的版本，与所指向的对象无关； 引用数据类型之间的转换 引用数据类型之间的转换分为两种：自动类型转换 和 强制类型转换。 其中子类类型向父类类型之间的转换发生自动类型转换； 其中父类类型向子类类型之间的转换发生强制类型转换； 引用数据类型之间的转换必须发生在父子类之间，否则编译报错。 若引用要强转的目标类型不是该引用真正指向的子类类型，则编译通过，运行阶段发生 类型转换异常。 为了避免上述错误的发生，以后在强制类型转换之前都应该进行类型的判断，如下： if(引用变量名 instanceof 目标类型) 用于判断引用真正指向的对象类型是否为目标类型，若是则返回true，否返回false 多态的实际意义 多态的实际意义在于屏蔽不同子类之间的差异性实现通用的编程，从而带来不同的结果。]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年学过的Hibernate笔记]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E5%AD%A6%E8%BF%87%E7%9A%84Hibernate%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Hibernate框架属于ORM工具，以对象方式实现对数据库的操作。例如Hibernate、MyBatis、JPA等。学习知识： 1.Hibernate基本使用（单表各种操作） 2.Hibernate查询操作（HQL、Criteria、SQL） 3.Hibernate关联映射（一对多、多对一等） 4.Hibernate框架特性（延迟加载、缓存、持久化等） 5.Spring和Hibernate整合（SSH整合） Hibernate基本使用 导入hibernate-core包和驱动包&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.42&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.3.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加hibernate.cfg.xml配置文件&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt; jdbc:mysql://localhost:3306/ovls?useUnicode=true&amp;amp;characterEncoding=utf8 &lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;1234&lt;/property&gt; &lt;property name=&quot;connection.driver_class&quot;&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;!-- 加载映射描述信息 --&gt; &lt;mapping resource=&quot;hbm/Direction.hbm.xml&quot; /&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 编写实体类public class Direction implements Serializable{ private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 编写映射描述文件&lt;hibernate-mapping&gt; &lt;class name=&quot;cn.xdl.entity.Direction&quot; table=&quot;DIRECTION&quot;&gt; &lt;!-- 主键映射用id元素 --&gt; &lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;integer&quot;&gt;&lt;/id&gt; &lt;!-- 非主键用property --&gt; &lt;property name=&quot;name&quot; column=&quot;NAME&quot; type=&quot;string&quot;&gt;&lt;/property&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 获取Session对象操作实体对象Configuration conf = new Configuration(); conf.configure(&quot;hibernate.cfg.xml&quot;);//加载hibernate.cfg.xml SessionFactory factory = conf.buildSessionFactory(); Session session = factory.openSession(); //等价于findById Direction direction = session.get(Direction.class, 1); session.close(); Hibernate单表处理1.添加操作Transaction tx = session.beginTransaction(); session.save(obj);//执行insert操作 tx.commit(); 添加记录时，Hibernate提供了多种主键生成器，管理主键值。 assigned 默认值，表示Hibernate不负责生成ID值，需要使用者调用setXxx方法代码设置。 sequence 表示使用序列生成ID值，适合Oracle、DB2. &lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;integer&quot;&gt; &lt;generator class=&quot;sequence&quot;&gt; &lt;param name=&quot;sequence&quot;&gt;direction_seq&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; identity 表示利用数据库自动增长功能生成ID值。适合MySQL、SQLServer. &lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;integer&quot;&gt; &lt;generator class=&quot;identity&quot;&gt; &lt;/generator&gt; &lt;/id&gt; native 表示根据dialect方言类型，自动选择identity、sequence、hilo等机制 &lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;integer&quot;&gt; &lt;generator class=&quot;native&quot;&gt; &lt;/generator&gt; &lt;/id&gt; increment 先查询ID最大值，然后再加1执行插入。 &lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;integer&quot;&gt; &lt;generator class=&quot;increment&quot;&gt; &lt;/generator&gt; &lt;/id&gt; hilo/uuid 采用高低位hilo算法、uuid算法生成ID值。 &lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;integer&quot;&gt; &lt;generator class=&quot;uuid&quot;&gt; &lt;/generator&gt; &lt;/id&gt; 自定义生成器 编写一个主键生成器类，实现IdentifierGenerator接口及方法。 &lt;id name=&quot;id&quot; column=&quot;ID&quot; type=&quot;integer&quot;&gt; &lt;generator class=&quot;cn.xdl.id.GeneratorId&quot;&gt;&lt;/generator&gt; &lt;/id&gt; 2.更新操作 整体更新 Transaction tx = session.beginTransaction(); session.update(obj);//根据ID更新其他属性 tx.commit(); 部分更新 方案：先查询，然后修改部分属性，再进行update Transaction tx = session.beginTransaction(); Subject subject = session.get(Subject.class, 1);//按ID查询 subject.setName(&quot;HTML/CSS&quot;); session.update(subject);//根据ID条件整体更新 tx.commit(); 3.删除操作 单行删除 Transaction tx = session.beginTransaction(); Direction direction = new Direction(); direction.setId(30); session.delete(direction);//按ID删除 tx.commit(); 多行删除(批量删除，借助HQL等操作) Transaction tx = session.beginTransaction(); String hql = &quot;delete from Subject where directionId=:id&quot;; Query query = session.createQuery(hql); query.setParameter(&quot;id&quot;, 8);//第一个?给8 query.executeUpdate();//执行删除语句 tx.commit(); 4.查询操作 按ID做条件查询 //get立刻加载查询 Direction direction = session.get(Direction.class, 1); //load延迟加载查询 Direction direction = session.load(Direction.class, 1); 按其他字段做条件查询 使用HQL、Criteria、SQL方法操作。 Transaction tx = session.beginTransaction(); String hql = &quot;from Direction where name like :name&quot;; Query query = session.createQuery(hql); query.setParameter(&quot;name&quot;, &quot;%开发%&quot;); List&lt;Direction&gt; list = query.list(); Hibernate注解映射实体类注解描述映射@Entity @Table(name=&quot;DIRECTION&quot;) public class Direction implements Serializable{ @Id @Column(name=&quot;ID&quot;) @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; @Column(name=&quot;NAME&quot;) private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } hibernate.cfg.xml加载映射描述&lt;mapping class=&quot;cn.xdl.entity.Direction&quot;/&gt; Hibernate查询操作HQL（Hibernate Query Language）HQL和SQL相似，都支持select…from…where…group by…having… order by… 不同点如下： HQL属于面向对象查询，元素使用映射类型和属性 HQL大小写敏感语句，类名和属性名注意大小写 HQL不支持select *写法，如果需要获取所有列值，可以省略select子句. HQL不支持join…on…连接中的on子句，多表需要使用关联映射 HQL不能使用数据库特有函数或关键字 SQL : select * from direction where id=?HQL : from Direction where id=:id Criteria用法（条件查询）@Test public void test2(){ Session session = HibernateUtil.openSession(); //1.创建CriteriaBuilder,用于创建查询 CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); //2.创建CriteriaQuery,用于设置查询语句的信息 CriteriaQuery&lt;Direction&gt; criteriaQuery = criteriaBuilder.createQuery(Direction.class); //3.定义查询的From子句中能出现的类型,也可以用root.get()获取具体的某个属性 Root&lt;Direction&gt; root = criteriaQuery.from(Direction.class); //4.设置WHERE字句的条件，此处条件为id&lt; 5 criteriaQuery.where(criteriaBuilder.lt( root.get(&quot;id&quot;), 5)); //5.设置排序标准与排序方式 criteriaQuery.orderBy(criteriaBuilder.desc(root.get(&quot;id&quot;))); //6.使用criteriaQuery查询 Query&lt;Direction&gt; query = session.createQuery(criteriaQuery); List&lt;Direction&gt; list = query.getResultList(); for(Direction d : list){ System.out.println(d.getId()+&quot; &quot;+d.getName()); } session.close(); } NativeSQL（原生SQL） 查询所有记录（默认Object[]封装记录） @Test public void test1(){ Session session = HibernateUtil.openSession(); String sql = &quot;select id,name from direction&quot;; NativeQuery query = session.createNativeQuery(sql); List&lt;Object[]&gt; list = query.getResultList(); for(Object[] objs:list){ System.out.println(objs[0]+&quot; &quot;+objs[1]); } session.close(); } 查询所有记录（采用指定类型封装记录） @Test public void test2(){ Session session = HibernateUtil.openSession(); String sql = &quot;select id,name from direction&quot;; NativeQuery&lt;Direction&gt; query = session.createNativeQuery(sql,Direction.class); List&lt;Direction&gt; list = query.getResultList(); for(Direction d:list){ System.out.println(d.getId()+&quot; &quot;+d.getName()); } session.close(); } 分页查询 @Test public void test3(){ Session session = HibernateUtil.openSession(); String sql = &quot;select id,name from direction&quot;; NativeQuery&lt;Direction&gt; query = session.createNativeQuery(sql,Direction.class); //设置分页 query.setFirstResult(0); query.setMaxResults(5); List&lt;Direction&gt; list = query.getResultList(); for(Direction d:list){ System.out.println(d.getId()+&quot; &quot;+d.getName()); } session.close(); } 带条件参数查询 @Test public void test4(){ Session session = HibernateUtil.openSession(); String sql = &quot;select id,name from direction where name like ?&quot;; NativeQuery&lt;Direction&gt; query = session.createNativeQuery(sql,Direction.class); query.setParameter(1, &quot;%开发%&quot;); List&lt;Direction&gt; list = query.getResultList(); for(Direction d:list){ System.out.println(d.getId()+&quot; &quot;+d.getName()); } session.close(); } 提示：如果需要执行insert,update,delete语句可以使用query.executeUpdate()方法。 关联映射Hibernate关联映射类型有一对一、一对多、多对一、多对多等。 方向(Direction) 1方 &lt;---&gt; n方 学科(Subject) 1. 一对多由一条记录加载相关的多条记录信息。（由一个对象加载相关的多个对象信息，例如部门对象查找相关的员工对象。） @OneToMany(fetch=FetchType.LAZY)//利用一对多关系查找 @JoinColumn(name=&quot;direction_id&quot;)//要查找表的条件字段 private List&lt;Subject&gt; subjects;//多个相关的subject学科 2. 多对一由多方记录加载相关的一方记录信息。（例如员工对象找部门对象。） //追加属性，用于加载关联的方向对象 @ManyToOne @JoinColumn(name=&quot;DIRECTION_ID&quot;)//指定查询条件的字段值 private Direction direction; 3. 多对多试卷 n方 n方 试题一个试卷可以包含多个试题；一个试题可以在多个试卷中 @ManyToMany @JoinTable(name=&quot;paper_question&quot;, joinColumns={@JoinColumn(name=&quot;paper_id&quot;)}, inverseJoinColumns={@JoinColumn(name=&quot;question_id&quot;)}) private List&lt;Question&gt; questions; 关联操作 关联查询 String hql = &quot;select s.id,s.name,d.name &quot; + &quot;from Subject s left outer join s.direction d &quot; + &quot;where s.id=:sid&quot;; String hql = &quot;select s.id,s.name,s.direction.name &quot; + &quot;from Subject s &quot; + &quot;where s.id=:sid&quot;; 级联删除 @OneToMany(fetch=FetchType.LAZY,cascade={CascadeType.ALL})//利用一对多关系查找 @JoinColumn(name=&quot;direction_id&quot;)//要查找表的条件字段 private List&lt;Subject&gt; subjects;//多个相关的subject学科 提示：不推荐使用，采用大量delete语句删除，语句数量跟关联记录数量有关。 Hibernate特性延迟加载在Hibernate某些方法时，具有延迟加载特性。也就是说执行了方法后，并没有立刻发送SQL查询数据库，而是在后续实体对象操作时才触发SQL发送和执行。 load query.iterate 关联映射属性值 org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: cn.xdl.entity.Direction.subjects, could not initialize proxy - no Session 上述异常产生原因：使用了延迟加载方法，但是session关闭过早导致，应该放在加载完毕后关闭。 在项目中，请求–&gt;MVC控制器–&gt;Action/Controller–&gt;Service–&gt;Dao(查，不关闭Session)–&gt;JSP(取)–&gt;关闭Session–&gt;响应输出，可以使用Filter、Interceptor等技术将session关闭放到JSP解析之后。在Spring中有一个OpenSessionInViewFilter/Interceptor组件，使用时只需要配置下即可。 get //立刻加载，对应load query.list/getResultList //立刻加载 关联映射属性采用join fetch策略 //立刻加载 //先加载direction,延迟加载subjects &quot;from Direction d where d.id=:id&quot;; //立刻加载direction和subjects &quot;from Direction d join fetch d.subjects where d.id=:id&quot;; 延迟加载优点： 减少并发几率 提升内存空间资源利用率 也是为关联映射做基础 持久化Hibernate为应用程序构建一个持久层。 持久层中都是持久对象，指的是实体对象，这些对象状态改变后可以与数据库保持同步更新。持久对象垃圾回收器不能回收。 Hibernate中实体对象有以下三种状态： 临时对象(刚创建未进入session缓存区) 使用new创建的对象。 持久对象(进入session缓存区) 使用session的load、get、save、update方法操作的对象。 游离对象(从session缓存区移除) 原来属于持久对象，后来调用了session的close、clear、evict方法。 提示：持久对象在调用flush或commit方法后，会执行一个update将对象状态更新到数据库中。 缓存Hibernate缓存分为一级、二级、查询缓存。 一级缓存 默认开启 Session级别缓存（一个Session拥有一个缓存区） 跟随Session产生，close方法销毁 Session缓存独享，不能交叉访问 缓存的作用如下 缓存对象持久化 load/get查询，先查缓存，没有再查数据库 手动管理缓存方法 clear() //清空缓存所有对象 evict(obj) //清除指定缓存对象 执行get/load/save/update方法会自动将对象放入缓存 批量更新和添加问题： tx = session.beginTransaction(); for(int i=1;i&lt;10000;i++){ session.save(obj); if(i%100==0){ session.flush(); session.clear(); } } tx.commit(); 二级缓存 默认关闭，需要开启 属于SessionFactory级别缓存 SessionFactory创建的多个Session可以共享二级缓存空间 声明周期与SessionFactory相同 开启方法如下： 添加二级缓存组件包和配置文件(ehcache.jar和ehcache.xml) &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt; &lt;version&gt;5.2.8.Final&lt;/version&gt; &lt;/dependency&gt; 在hibernate.cfg.xml开启二级缓存设置，指定缓存驱动类 &lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hibernate.cache.region.factory_class&quot;&gt; org.hibernate.cache.ehcache.EhCacheRegionFactory &lt;/property&gt; 在映射描述中指定Cache元素，表示采用二级缓存存储 @Entity @Table(name=&quot;DIRECTION&quot;) @Cache(usage=CacheConcurrencyStrategy.READ_WRITE) public class Direction implements Serializable{ ... ... } 查询缓存 默认关闭，需要开启 一级和二级只能缓存单个对象，查询缓存可以缓存结果集 查询缓存开启过程 启用二级缓存操作 在hibernate.cfg.xml配置开启查询缓存 &lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt; 在查询语句执行前设置采用查询机制执行 String hql = &quot;from Direction&quot;; Query&lt;Direction&gt; query = session.createQuery(hql); query.setCacheable(true);//启用查询缓存 List&lt;Direction&gt; list = query.getResultList();//返回List集合]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年我整理的SE面试题]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E6%88%91%E6%95%B4%E7%90%86%E7%9A%84JavaSE%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaSE基础知识1.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 可以有多个类,但只能有个public的类,并且public的类名必须与文件名保持一致 2.Java 有没有 goto goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 JamesGosling（Java 之父）编写的 《TheJava ProgrammingLanguage》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const， 但是这两个是目前无 法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义， 因为熟悉 C 语言的 程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 3.说说&amp;和&amp;&amp;的区别？ 1 &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and) 2 &amp;&amp;具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式 3 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是 boolean 类型时，&amp;表示按位与操作，我们通常使用 0x0f 来与一个整数进行&amp;运算，来获取该整数的最低 4 个 bit 位，例如，0x31&amp;0x0f 的结果为 0x01。4 short s1=1;s1=s1+1;有什么错？ short s1=1;s1+=1;有什么错？ 1 对于 shorts1=1;s1=s1+1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。 2 对于 shorts1=1;s1+=1;由于 += 是 java 语言规定的运算符，java 编译器会对它进行特殊处理，因此可以 正确编译。 5 char 型变量中能不能存贮一个中文汉字？为什么？ char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，char 型变量中当 然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占用两个字节，所以，char 类型的变量也是占用两个字节。 6 最有效率的方法算出 2 乘以 8 等於几？ 2&lt;&lt;3，因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3 位即可， 而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2&lt;&lt;3 7 floatf=3.4;是否正确？ 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型 （down-casting，也称为窄 化）会造成精度损失，因此需要强制类型转换 floatf=(float)3.4; 或者写成 floatf=3.4F;。 8 在Java中如何跳出当前循环? 如何跳出多重循环? break; return 9 数据类型之间的转换? 1 如何将字符串转换为基本数据类型? 调用基本数据类型对应的包装类中的方法 parseXXX(String)或 valueOf(String)即可返回相应基本类型 2 如何将基本数据类型转换为字符串？ (1) 一种方法是将基本数据类型与空字符串（&quot;&quot;）连接（+）即可获得其所对应的字符串； (2) 一种方法是调用 String 类中的 valueOf()方法返回相应字符串 10 JDK和JRE的关系区别是什么？ JDK是Java的开发工具，JDK包含JRE JRE只是Java程序的运行环境，它最核心的内容就是JVM（Java虚拟机）及核心类库 JavaSE面向对象1 静态变量和实例变量的区别? 1 语法定义:静态变量前要加 static 关键字，而实例变量前则不加 2 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配 空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载 了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量 必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用 2 重载和重写的区别? 重载: 1 方法名相同,参数列表不同的多个方法之间构成重载关系 2 参数列表中参数类型、个数、顺序至少有一个不同 3 重载关系存在于父类,子类和同类中 重写: 当子类从父类继承的方法不足以满足子类的需求时,需要重写该方法 重写原则: 1 方法名,返回值类型,参数列表相同 2 不能抛出更大更多的异常 3 访问权限不能变小 4 由final修饰的方法表示该不能被重写 3 final关键字的用法? 1 修饰类,表示该类不能被继承 2 修饰方法,表示该方法不能被重写 3 修饰变量,表示该变量必须被初始化,而且值不能更改 4 final,finally和finalize的区别? final关键字: 修饰成员变量,表示必须被初始化不可修改 修饰成员方法,表示该方法不能被重写 修饰类,表示该类不能被继承 finally:配合try...catch使用 表示最终会被执行,一般用于资源的释放 finalize:Object中的方法,主要用于CG垃圾回收之前的清理工作 5 是否可以从一个 static 方法内部发出对非 static 方法的调用？ 不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调 用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一个 static 方法被调用时， 可能还没有 创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上 的呢？这个逻辑无法成立，所以，一个 static 方法内部发出对非 static 方法的调用。 6 请说出作用域 public，private，protected，以及不写时的区别？ 访问控制符 访问权限 本类 本包中的类 子类 其它包的类 public 公有的 Y Y Y Y protected 保护的 Y Y Y N 空 默认的 Y Y N N private 私有的 Y N N N 7 面向对象的特征有哪些方面？ 1 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关 注对象有哪些属性和行为，并不关注这些行为的细节是什么。 2 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）； 得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中 可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中关于桥梁模式的部 分）。 3 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质 就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封 装； 我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编 程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单； 我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 4 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用 调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对 象向外界提供的服务，那么运行时的多态性可以解释为： 当 A 系统访问 B 系统提供的服务时，B 系统有多种提供 服务的方式，但一切对 A 系统来说都是透明的（ 就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以 使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供 电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也 称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象 最精髓的东西，要实现多态需要做两件事： （a）方法重写（子类继承父类并重写父类中已有的或抽象的方法）； （b）对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表 现出不同的行为）。 8 构造器（constructor）是否可被重写（override）？ 构造器不能被继承，因此不能被重写，但可以被重载 9 描述一下 JVM 加载 class 文件的原理机制？ 10 JVM内存结构? 11 Java中会存在内存泄漏吗，请简单描述？ 理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的 一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致 内存泄露的发生。例如 Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些 对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能 导致内存泄露 12 GC 是什么？为什么要有 GC？ GC 是垃圾收集的意思Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的， 从而有效的防止内存泄露。 要请求垃圾收集，可以调用下面的方法之一：System.gc()或Runtime.getRuntim().gc() ,但JVM 可以屏蔽掉显示的垃圾回收调用。 13 heap 和 stack 有什么区别？ java 的内存分为两类，一类是栈内存，一类是堆内存。 栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new 创建的对象都 放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final 修饰后，放在堆中，而不是栈中 14 解释内存中的栈(stack)、堆(heap)和静态区(staticarea)的用法？ 1 通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的 栈空间； 2 而通过 new 关键字和构造器创建的对象放在堆空间； 3 程序中的字面量（literal）如直接书写的 100、&quot;hello&quot;和常量都是放在静态区中。 4 栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用 的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。 5 例如：Stringstr=newString(&quot;hello&quot;); 上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而&quot;hello&quot;这个字面量放在静态区。 JavaSE核心类库核心类库1 “==”和 equals 方法究竟有什么区别？ ==：比较两个数据内存地址是否相同 equals：比较两个数据值是否一样 2 abstract class和interface有什么区别? （1）成员特点： 构造方法：接口没有；抽象类有； 成员变量：接口中只有常量；抽象类中常量、变量都可； 成员方法：接口只有抽象方法；抽象类中抽象方法、非抽象方法都可； （2）关系特点： 类与类：只有单继承，但可以多层继承； 类与接口：实现关系，可以单实现，也可以多实现； 接口与接口：继承关系，可以单继承，也可以多继承； （3）设计理念： 接口是简单工厂设计模式，likea 的关系 ,接口中定义的是该继承体系的扩展功能； 抽象类是模板设计模式，isa 的关系，抽象类中定义的是继承体系的共性功能； 3 Integer 与 int 的区别 ? 1 int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 java 为 int 提供 的封装类。int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无 法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开 发中，Integer 的默认为 null，所以用 el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为 0， 所以用 el 表达式在文本框中显示时，结果为 0，所以，int 不适合作为 web 层的表单数据的类型。 2 在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null 而判断一个 对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中设置其 unsaved-value 属性为 0。 3 另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer 中还定义了 表示整数的最大值和最小值的常量。 4 Math.round(11.5)等於多少？ Math.round(-11.5)等於多少？ round 方法，它表示“四舍五入”，算法为 Math.floor(x+0.5)， 即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5)的结果为 12，Math.round(-11.5)的结果为-11。 5 String 和 StringBuilder、StringBuffer 的区别？ 1 String 和 StringBuffer、StringBuider： (1) String：是不可变字符序列； (2) StringBuffer、StringBuider：是可变字符序列； (3) String 覆盖了 equals 方法和 hashCode 方法，而 StringBuffer 没有覆盖 equals 方法和 hashCode 方法， 所以，将 StringBuffer 对象存储进 Java 集合类中时会出现问题。 2 StringBuffer 和 StringBuider： (1) StringBuffer：是 JDK1.0 版本的，线程安全，效率低； (2) StringBuilder：是 JDK1.5 版本的，线程不安全，效率高； (3) 如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了， 则用 StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最 好用 StringBuffer 6 Collection 和 Collections的区别？ 答：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器 操作，这些方法包括对容器的搜索、排序、线程安全化等等。 7 什么是java序列化，如何实现java序列化？ 1 序列化是一种处理对象流的机制,所谓对象流也就是将对象的内容进行流化(将对象转换成二进制) 2 实现序列化接口Serializable 3 反序列化是将字节序列恢复成Java对象的过程 8 HashTable和HashMap有什么区别？ 1.HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口 2.主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高Hashtable 3.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许 4.最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是 9 List和Map有什么区别？ list： - 链表 - 有序 - 继承Collection(set也是) - 可以有重复的对象值，但是对象下标不能重复 Map： - key-value - 无序 - 键不能有重复的 值可以用 10 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继 承抽象类。 11 Error和Exception 有什么区别？ 1 Error表示系统级的错误和程序不必处理的异常， 2 Exception表示需要捕捉或者需要进行异常处理，是一种设计或实现问题：它表示如果程序运行异常，从不会发生的情况12 字符流和字节流的区别 字节流:按照字节进行读写,可以读取任意数据 字符流:按照字符进行读写 字节流操作时不会被放到缓存区,而字符流在操作时使用了缓存区 线程&amp;网络编程&amp;and so on1 创建多线程的方式？ 1 继承Thread类，重写run方法 2 实现Runnable接口 3 使用匿名内部类的方式 2 请说出你所知道的线程同步的方法？ wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 3 同步和异步有何异同，在什么情况下分别使用他们？举例说明。 1 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 2 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 4 简述synchronized和java.util.concurrent.locks.Lock的异同 ？ 1 Lock能够完成synchronized所包含的所有功能 2 Lock 有比 synchronized 更精确的线程语义和更好的性能,synchronized会自动释放锁,而Lock一定要程序员手工释放,并且必须在finally从句中释放. 5 什么是线程池（thread pool）？ 1 池化思想: 提高服务程序 效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁 2 线程池: 事先创建若干个可执行的线程放入一个池(容器)中,需要的时候从池中获取线程不用自行创建,使用完毕不需要销毁线程而是放回池中,从而减少创建和销毁线程的开销. 6 run()和start()区别？ 启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行，这并不意味着线程就会立即运行。 run()方法是线程启动后要进行回调（callback）的方法 7 同步代码块与同步函数的区别？ （1）同步代码块：位置比较灵活，锁对象可以任意对象，但必须是同一对象。格式：synchronized(对象){// 任意对象都可以。这个对象就是锁。需要被同步的代码；} （2）同步函数：声明方法时加 synchronized 关键字，同步函数使用的锁是 this，静态同步函数的锁是该类的 字节码文件对象。 （3）在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。 所以同步代码块相对灵活一些。 8 获得一个类的类对象有哪些方式？ 1 Class.forName(classname);用作类加载 2 对象.getClass();用于获取对象的类型 3 类名.class; 用于获取指定的类型,传参 9 如何通过反射创建对象？ 1 调用无参的构造函数:使用Class类中的newInstance()方法 2 调用有参的构造函数:先获取指定的参数列表构造器,然后通过该构造函数的对象的 newInstance(实 际参数) 进行对象的初始化。 10 简述一下面向对象设计的”六原则”？ 1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 11 简述一下你了解的设计模式？ 设计模式: 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式本质上就是一种固定的套路，使用在固定的场合中。 分类: 创建型模式 - 工厂方法模式、抽象工厂模式、单例设计模式。 结构型模式 - 装饰器模式、代理模式。 行为型模式 - 模板设计模式、观察者模式。 12 Java写一个单例类？ public class Singleton{ private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; } } 13 单例设计模式的应用场景? 单例模式（Singleton），也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。 单例模式只允许创建一个对象，因此节省内存，加快对象访问速度 单例模式要素： a.私有构造方法 b.私有静态引用指向自己实例 c.以自己实例为返回值的公有静态方法 饿汉式：单例实例在类装载时就构建，急切初始化。（预先加载法） 优点 1.线程安全 2.在类加载的同时已经创建好一个静态对象，调用时反应速度快 缺点 资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 懒汉式：单例实例在第一次被使用时构建，延迟初始化。 应用场景： - 需要频繁实例化然后销毁的对象 - 创建对象时耗时过多或者耗资源过多，但又经常用到的对象 - 有状态的工具类对象 - 频繁访问数据库或文件的对象 - 网站计数器，一般是采用单例模式实现 - 由于配置文件一般都是共享资源，即web应用的配置对象的读取，一般采用单例模式来实现。如：spring的配置文件的读取等 - 多线程的线程池的设计一般也是采用单例模式 - 数据库连接池的设计 14 什么是SOA，谈谈你的SOA的理解？ （1）SOA 的概念 SOA（Service-oriented archITecture，面向服务架构），而 WebService 是实现 SOA 的其中一种方式，所以 两者并不是一个概念。 WebService 基于 SOAP 协议的，本质就是基于 XML 的，正是因为基于 XML，所以 SOA 才能整合不 同的平台，不同的应用。 （2）SOA 的作用： 1 整合异构系统。准确点说，整合企业的遗留系统、正在开发的系统 和即将开发的新系统。 不同的系统可 能采用不同的平台，如操作系统的选择；不同的开 发语言；不同的系统架构。 2 及时的响应用户的业务变化。大量的 SOA 组件，通过整合 和拆散，然后打包成一个个的粒度合适的 SOA 组件，再经过流程管理工具的处理，实现 业务的不断变化。 15 TCP和UDP的区别？哪个是三次握手协议？ TCP: 全程保持连接 是一种全双工的字节流传输格式 安全性高 16 简述线程的五种状态？ 1 新建 2 就绪 3 运行 4 阻塞 5 消亡 17 写出五种常见的异常 ArithmeticException 算术异常 NullPointException 空指针异常 ClassCastException 类型转换异常 NumberFormatException 数字格式异常 ArrayIndexOutOfBoundsException 数组下标越界异常 18 throw和throws的区别,处理方式? (1)throw用于抛出异常对象,后面跟的是异常对象 ;throw用在方法体内 (2)throws用于抛出异常类,后面跟的是异常类名,可以跟多个,用逗号隔开,throws用在方法上 (3)异常处理方式:异常的捕获-try{}catch{}finally{},异常的抛出throws,自定义异常类,继承Exception （4）什么时候定义 try，什么时候定义 throws？ ①功能内部如果出现异常，如果可以处理，就用 try； ②如果内部处理不了，就必须声明出来，让调用者处理。 数据库相关1 Statement 和 PreparedStatement 有什么区别？哪个性能更好？ (1) PrepareStatement代表预编译语句,主要优势在于减少SQL编译错误并增加SQL语句的安全性 (2) PreparedStatement 中的SQL语句可以带参数 (3) 当批量处理SQL或频繁执行相同的代码查询时,PreparedStatement有着明显的优势,因为数据库可以将编译优化后的SQL语句缓存起来. 2 JDBC连接数据库的步骤？ 1 加载驱动 Class.forName(&quot;数据库驱动&quot;); 2 创建连接 DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;); 3 创建语句 conn.Preparestament(sql); 4 执行语句 ps.executeQuery(); 5 处理结果 while(rs.next){} 6 释放资源 finally{ conn.close(); rs.close(); } 3 数据库性能优化？ 1 数据库设计 数据库表：字段命名、字段长度、类型、注释规范 数据库索引：外键、关联字段、查询比较高的字段 数据库视图：相当于临时表，尽量少用 数据库引擎：根据业务选择相应的引擎 数据库字符：和页面字符保持一致 数据库存储过程：尽量少用 数据库监听器/触发器：一般用于调度任务和备份还原 2 SQL语句优化 使用xml配置sql语句 尽量少关联表,效率最高关联四张表 不建议使用*号 查询语句where后,最好使用索引字段关联 3 数据库服务器搭建(集群) 主从配置 读写分离 自动化(容器)]]></content>
      <categories>
        <category>offer面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年我整理的JavaEE面试题]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E6%88%91%E6%95%B4%E7%90%86%E7%9A%84JavaEE%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaSE基础知识1.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 可以有多个类,但只能有个public的类,并且public的类名必须与文件名保持一致 2.Java 有没有 goto goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 JamesGosling（Java 之父）编写的 《TheJava ProgrammingLanguage》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const， 但是这两个是目前无 法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义， 因为熟悉 C 语言的 程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 3.说说&amp;和&amp;&amp;的区别？ 1 &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and) 2 &amp;&amp;具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式 3 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是 boolean 类型时，&amp;表示按位与操作，我们通常使用 0x0f 来与一个整数进行&amp;运算，来获取该整数的最低 4 个 bit 位，例如，0x31&amp;0x0f 的结果为 0x01。4 short s1=1;s1=s1+1;有什么错？ short s1=1;s1+=1;有什么错？ 1 对于 shorts1=1;s1=s1+1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。 2 对于 shorts1=1;s1+=1;由于 += 是 java 语言规定的运算符，java 编译器会对它进行特殊处理，因此可以 正确编译。 5 char 型变量中能不能存贮一个中文汉字？为什么？ char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，char 型变量中当 然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占用两个字节，所以，char 类型的变量也是占用两个字节。 6 最有效率的方法算出 2 乘以 8 等於几？ 2&lt;&lt;3，因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3 位即可， 而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2&lt;&lt;3 7 floatf=3.4;是否正确？ 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型 （down-casting，也称为窄 化）会造成精度损失，因此需要强制类型转换 floatf=(float)3.4; 或者写成 floatf=3.4F;。 8 在Java中如何跳出当前循环? 如何跳出多重循环? break; return 9 数据类型之间的转换? 1 如何将字符串转换为基本数据类型? 调用基本数据类型对应的包装类中的方法 parseXXX(String)或 valueOf(String)即可返回相应基本类型 2 如何将基本数据类型转换为字符串？ (1) 一种方法是将基本数据类型与空字符串（&quot;&quot;）连接（+）即可获得其所对应的字符串； (2) 一种方法是调用 String 类中的 valueOf()方法返回相应字符串 10 JDK和JRE的关系区别是什么？ JDK是Java的开发工具，JDK包含JRE JRE只是Java程序的运行环境，它最核心的内容就是JVM（Java虚拟机）及核心类库 JavaSE面向对象1 静态变量和实例变量的区别? 1 语法定义:静态变量前要加 static 关键字，而实例变量前则不加 2 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配 空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载 了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量 必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用 2 重载和重写的区别? 重载: 1 方法名相同,参数列表不同的多个方法之间构成重载关系 2 参数列表中参数类型、个数、顺序至少有一个不同 3 重载关系存在于父类,子类和同类中 重写: 当子类从父类继承的方法不足以满足子类的需求时,需要重写该方法 重写原则: 1 方法名,返回值类型,参数列表相同 2 不能抛出更大更多的异常 3 访问权限不能变小 4 由final修饰的方法表示该不能被重写 3 final关键字的用法? 1 修饰类,表示该类不能被继承 2 修饰方法,表示该方法不能被重写 3 修饰变量,表示该变量必须被初始化,而且值不能更改 4 final,finally和finalize的区别? final关键字: 修饰成员变量,表示必须被初始化不可修改 修饰成员方法,表示该方法不能被重写 修饰类,表示该类不能被继承 finally:配合try...catch使用 表示最终会被执行,一般用于资源的释放 finalize:Object中的方法,主要用于CG垃圾回收之前的清理工作 5 是否可以从一个 static 方法内部发出对非 static 方法的调用？ 不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调 用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一个 static 方法被调用时， 可能还没有 创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上 的呢？这个逻辑无法成立，所以，一个 static 方法内部发出对非 static 方法的调用。 6 请说出作用域 public，private，protected，以及不写时的区别？ 访问控制符 访问权限 本类 本包中的类 子类 其它包的类 public 公有的 Y Y Y Y protected 保护的 Y Y Y N 空 默认的 Y Y N N private 私有的 Y N N N 7 面向对象的特征有哪些方面？ 1 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关 注对象有哪些属性和行为，并不关注这些行为的细节是什么。 2 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）； 得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中 可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中关于桥梁模式的部 分）。 3 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质 就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封 装； 我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编 程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单； 我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 4 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用 调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对 象向外界提供的服务，那么运行时的多态性可以解释为： 当 A 系统访问 B 系统提供的服务时，B 系统有多种提供 服务的方式，但一切对 A 系统来说都是透明的（ 就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以 使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供 电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也 称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象 最精髓的东西，要实现多态需要做两件事： （a）方法重写（子类继承父类并重写父类中已有的或抽象的方法）； （b）对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表 现出不同的行为）。 8 构造器（constructor）是否可被重写（override）？ 构造器不能被继承，因此不能被重写，但可以被重载 9 描述一下 JVM 加载 class 文件的原理机制？ 10 JVM内存结构? 11 Java中会存在内存泄漏吗，请简单描述？ 理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的 一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致 内存泄露的发生。例如 Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些 对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能 导致内存泄露 12 GC 是什么？为什么要有 GC？ GC 是垃圾收集的意思Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的， 从而有效的防止内存泄露。 要请求垃圾收集，可以调用下面的方法之一：System.gc()或Runtime.getRuntim().gc() ,但JVM 可以屏蔽掉显示的垃圾回收调用。 13 heap 和 stack 有什么区别？ java 的内存分为两类，一类是栈内存，一类是堆内存。 栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new 创建的对象都 放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final 修饰后，放在堆中，而不是栈中 14 解释内存中的栈(stack)、堆(heap)和静态区(staticarea)的用法？ 1 通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的 栈空间； 2 而通过 new 关键字和构造器创建的对象放在堆空间； 3 程序中的字面量（literal）如直接书写的 100、&quot;hello&quot;和常量都是放在静态区中。 4 栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用 的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。 5 例如：Stringstr=newString(&quot;hello&quot;); 上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而&quot;hello&quot;这个字面量放在静态区。 JavaSE核心类库核心类库1 “==”和 equals 方法究竟有什么区别？ ==：比较两个数据内存地址是否相同 equals：比较两个数据值是否一样 2 abstract class和interface有什么区别? （1）成员特点： 构造方法：接口没有；抽象类有； 成员变量：接口中只有常量；抽象类中常量、变量都可； 成员方法：接口只有抽象方法；抽象类中抽象方法、非抽象方法都可； （2）关系特点： 类与类：只有单继承，但可以多层继承； 类与接口：实现关系，可以单实现，也可以多实现； 接口与接口：继承关系，可以单继承，也可以多继承； （3）设计理念： 接口是简单工厂设计模式，likea 的关系 ,接口中定义的是该继承体系的扩展功能； 抽象类是模板设计模式，isa 的关系，抽象类中定义的是继承体系的共性功能； 3 Integer 与 int 的区别 ? 1 int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 java 为 int 提供 的封装类。int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无 法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开 发中，Integer 的默认为 null，所以用 el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为 0， 所以用 el 表达式在文本框中显示时，结果为 0，所以，int 不适合作为 web 层的表单数据的类型。 2 在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null 而判断一个 对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中设置其 unsaved-value 属性为 0。 3 另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer 中还定义了 表示整数的最大值和最小值的常量。 4 Math.round(11.5)等於多少？ Math.round(-11.5)等於多少？ round 方法，它表示“四舍五入”，算法为 Math.floor(x+0.5)， 即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5)的结果为 12，Math.round(-11.5)的结果为-11。 5 String 和 StringBuilder、StringBuffer 的区别？ 1 String 和 StringBuffer、StringBuider： (1) String：是不可变字符序列； (2) StringBuffer、StringBuider：是可变字符序列； (3) String 覆盖了 equals 方法和 hashCode 方法，而 StringBuffer 没有覆盖 equals 方法和 hashCode 方法， 所以，将 StringBuffer 对象存储进 Java 集合类中时会出现问题。 2 StringBuffer 和 StringBuider： (1) StringBuffer：是 JDK1.0 版本的，线程安全，效率低； (2) StringBuilder：是 JDK1.5 版本的，线程不安全，效率高； (3) 如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了， 则用 StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最 好用 StringBuffer 6 Collection 和 Collections的区别？ 答：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器 操作，这些方法包括对容器的搜索、排序、线程安全化等等。 7 什么是java序列化，如何实现java序列化？ 1 序列化是一种处理对象流的机制,所谓对象流也就是将对象的内容进行流化(将对象转换成二进制) 2 实现序列化接口Serializable 3 反序列化是将字节序列恢复成Java对象的过程 8 HashTable和HashMap有什么区别？ 1.HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口 2.主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高Hashtable 3.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许 4.最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是 9 List和Map有什么区别？ list： - 链表 - 有序 - 继承Collection(set也是) - 可以有重复的对象值，但是对象下标不能重复 Map： - key-value - 无序 - 键不能有重复的 值可以用 10 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继 承抽象类。 11 Error和Exception 有什么区别？ 1 Error表示系统级的错误和程序不必处理的异常， 2 Exception表示需要捕捉或者需要进行异常处理，是一种设计或实现问题：它表示如果程序运行异常，从不会发生的情况12 字符流和字节流的区别 字节流:按照字节进行读写,可以读取任意数据 字符流:按照字符进行读写 字节流操作时不会被放到缓存区,而字符流在操作时使用了缓存区 线程&amp;网络编程&amp;and so on1 创建多线程的方式？ 1 继承Thread类，重写run方法 2 实现Runnable接口 3 使用匿名内部类的方式 2 请说出你所知道的线程同步的方法？ wait():使一个线程处于等待状态，并且释放所持有的对象的lock。 sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 3 同步和异步有何异同，在什么情况下分别使用他们？举例说明。 1 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 2 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 4 简述synchronized和java.util.concurrent.locks.Lock的异同 ？ 1 Lock能够完成synchronized所包含的所有功能 2 Lock 有比 synchronized 更精确的线程语义和更好的性能,synchronized会自动释放锁,而Lock一定要程序员手工释放,并且必须在finally从句中释放. 5 什么是线程池（thread pool）？ 1 池化思想: 提高服务程序 效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁 2 线程池: 事先创建若干个可执行的线程放入一个池(容器)中,需要的时候从池中获取线程不用自行创建,使用完毕不需要销毁线程而是放回池中,从而减少创建和销毁线程的开销. 6 run()和start()区别？ 启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行，这并不意味着线程就会立即运行。 run()方法是线程启动后要进行回调（callback）的方法 7 同步代码块与同步函数的区别？ （1）同步代码块：位置比较灵活，锁对象可以任意对象，但必须是同一对象。格式：synchronized(对象){// 任意对象都可以。这个对象就是锁。需要被同步的代码；} （2）同步函数：声明方法时加 synchronized 关键字，同步函数使用的锁是 this，静态同步函数的锁是该类的 字节码文件对象。 （3）在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。 所以同步代码块相对灵活一些。 8 获得一个类的类对象有哪些方式？ 1 Class.forName(classname);用作类加载 2 对象.getClass();用于获取对象的类型 3 类名.class; 用于获取指定的类型,传参 9 如何通过反射创建对象？ 1 调用无参的构造函数:使用Class类中的newInstance()方法 2 调用有参的构造函数:先获取指定的参数列表构造器,然后通过该构造函数的对象的 newInstance(实 际参数) 进行对象的初始化。 10 简述一下面向对象设计的”六原则”？ 1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 11 简述一下你了解的设计模式？ 设计模式: 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式本质上就是一种固定的套路，使用在固定的场合中。 分类: 创建型模式 - 工厂方法模式、抽象工厂模式、单例设计模式。 结构型模式 - 装饰器模式、代理模式。 行为型模式 - 模板设计模式、观察者模式。 12 Java写一个单例类？ public class Singleton{ private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; } } 13 单例设计模式的应用场景? 单例模式（Singleton），也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。 单例模式只允许创建一个对象，因此节省内存，加快对象访问速度 单例模式要素： a.私有构造方法 b.私有静态引用指向自己实例 c.以自己实例为返回值的公有静态方法 饿汉式：单例实例在类装载时就构建，急切初始化。（预先加载法） 优点 1.线程安全 2.在类加载的同时已经创建好一个静态对象，调用时反应速度快 缺点 资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 懒汉式：单例实例在第一次被使用时构建，延迟初始化。 应用场景： - 需要频繁实例化然后销毁的对象 - 创建对象时耗时过多或者耗资源过多，但又经常用到的对象 - 有状态的工具类对象 - 频繁访问数据库或文件的对象 - 网站计数器，一般是采用单例模式实现 - 由于配置文件一般都是共享资源，即web应用的配置对象的读取，一般采用单例模式来实现。如：spring的配置文件的读取等 - 多线程的线程池的设计一般也是采用单例模式 - 数据库连接池的设计 14 什么是SOA，谈谈你的SOA的理解？ （1）SOA 的概念 SOA（Service-oriented archITecture，面向服务架构），而 WebService 是实现 SOA 的其中一种方式，所以 两者并不是一个概念。 WebService 基于 SOAP 协议的，本质就是基于 XML 的，正是因为基于 XML，所以 SOA 才能整合不 同的平台，不同的应用。 （2）SOA 的作用： 1 整合异构系统。准确点说，整合企业的遗留系统、正在开发的系统 和即将开发的新系统。 不同的系统可 能采用不同的平台，如操作系统的选择；不同的开 发语言；不同的系统架构。 2 及时的响应用户的业务变化。大量的 SOA 组件，通过整合 和拆散，然后打包成一个个的粒度合适的 SOA 组件，再经过流程管理工具的处理，实现 业务的不断变化。 15 TCP和UDP的区别？哪个是三次握手协议？ TCP: 全程保持连接 是一种全双工的字节流传输格式 安全性高 16 简述线程的五种状态？ 1 新建 2 就绪 3 运行 4 阻塞 5 消亡 17 写出五种常见的异常 ArithmeticException 算术异常 NullPointException 空指针异常 ClassCastException 类型转换异常 NumberFormatException 数字格式异常 ArrayIndexOutOfBoundsException 数组下标越界异常 18 throw和throws的区别,处理方式? (1)throw用于抛出异常对象,后面跟的是异常对象 ;throw用在方法体内 (2)throws用于抛出异常类,后面跟的是异常类名,可以跟多个,用逗号隔开,throws用在方法上 (3)异常处理方式:异常的捕获-try{}catch{}finally{},异常的抛出throws,自定义异常类,继承Exception （4）什么时候定义 try，什么时候定义 throws？ ①功能内部如果出现异常，如果可以处理，就用 try； ②如果内部处理不了，就必须声明出来，让调用者处理。 数据库相关1 Statement 和 PreparedStatement 有什么区别？哪个性能更好？ (1) PrepareStatement代表预编译语句,主要优势在于减少SQL编译错误并增加SQL语句的安全性 (2) PreparedStatement 中的SQL语句可以带参数 (3) 当批量处理SQL或频繁执行相同的代码查询时,PreparedStatement有着明显的优势,因为数据库可以将编译优化后的SQL语句缓存起来. 2 JDBC连接数据库的步骤？ 1 加载驱动 Class.forName(&quot;数据库驱动&quot;); 2 创建连接 DriverManager.getConnection(&quot;&quot;,&quot;&quot;,&quot;&quot;); 3 创建语句 conn.Preparestament(sql); 4 执行语句 ps.executeQuery(); 5 处理结果 while(rs.next){} 6 释放资源 finally{ conn.close(); rs.close(); } 3 数据库性能优化？ 1 数据库设计 数据库表：字段命名、字段长度、类型、注释规范 数据库索引：外键、关联字段、查询比较高的字段 数据库视图：相当于临时表，尽量少用 数据库引擎：根据业务选择相应的引擎 数据库字符：和页面字符保持一致 数据库存储过程：尽量少用 数据库监听器/触发器：一般用于调度任务和备份还原 2 SQL语句优化 使用xml配置sql语句 尽量少关联表,效率最高关联四张表 不建议使用*号 查询语句where后,最好使用索引字段关联 3 数据库服务器搭建(集群) 主从配置 读写分离 自动化(容器)]]></content>
      <categories>
        <category>offer面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年我学过的Spring笔记]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E6%88%91%E5%AD%A6%E8%BF%87%E7%9A%84Spring%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Spring组成 Spring IOC Spring容器 在Spring中，任何的Java类都被当成Bean 组件，通过容器管理和使用。 Spring容器实现了IOC和AOP机制 Spring容器有ApplicationContext和 BeanFactory两种类型 建议使用ApplicationContext Bean对象的创建spring容器创建Bean对象的三种方法 使用构造器来实例化 //构造器配置 Bean组件定义格式 &lt;bean id=“标识符&quot; class=“包名.类名&quot;/&gt; 使用静态工厂方法实例化 //静态工厂方法配置 Bean组件定义格式 &lt;bean id=“标识符” class=“包名.类名“ factory-method=“静态方法名” /&gt; 使用实例工厂方法实例化//动态工厂方法配置 Bean组件定义格式 &lt;bean id=“标识符” factory-bean=“对象id“ factory-method=“方法名” /&gt; 从ApplicationContext容器中获取Bean组件类型 变量名 = 容器对象 . getBean (“ 标识符 ”, 组件类型 ) Bean对象的作用域 Bean对象初始化、销毁、延迟实例化指定Spring容器中创建Bean对象初始化&lt;beans default-init-method=“初始化方法名&quot;&gt; &lt;bean id=&quot;标识符&quot; class=&quot;类“/&gt; &lt;/beans&gt; 或者 &lt;beans&gt; &lt;bean id=&quot;标识符&quot; class=&quot;类“ init-method =“初始化方法名&quot;/&gt; &lt;/beans&gt; 指定Spring容器中创建Bean对象初始化&lt;beans default-destroy-method=“销毁方法名&quot;&gt; &lt;bean id=&quot;标识符&quot; class=&quot;类“/&gt; &lt;/beans&gt; 或者 &lt;beans&gt; &lt;bean id=&quot;标识符&quot; class=&quot;类“ destroy-method =“销毁方法名&quot;/&gt; &lt;/beans&gt; Bean对象的延迟实例化默认情况下，容器对象创建时Bean对象就会 创建，可以指定实例化延迟 &lt;beans default-lazy-init=“true&quot;&gt; &lt;bean id=&quot;标识符&quot; class=&quot;类“/&gt; &lt;/beans&gt; 或者 &lt;beans&gt; &lt;bean id=&quot;标识符&quot; class=&quot;类” lazy-init=“true&quot;/&gt; &lt;/beans&gt; DI依赖注入 Bean参数注入注入字符串&lt;bean id=&quot;msg&quot; class=&quot;com.xdl.bean.OracleDataSource&quot;&gt; &lt;property name=“username&quot; value=“scott&quot;/&gt; &lt;property name=“password“ &gt;&lt;value&gt;tiger&lt;/value&gt; &lt;property&gt; &lt;property name=“msg“ &gt; &lt;null/&gt; &lt;/property&gt; &lt;/bean&gt; 通过、、及 元素可以定义和设置与Java类型中对应List、 Set、Map及Properties的属性值 Map集合注入&lt;bean id=&quot;demo&quot; class=&quot;com.xdl.bean.DemoBean&quot;&gt; &lt;property name=&quot;score&quot;&gt; &lt;map&gt; &lt;entry key=“1001&quot; value=“99&quot;/&gt; &lt;entry key=“1002&quot; value=“100&quot;/&gt; &lt;entry key=&quot;1003&quot; value=&quot;98&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; Properties集合注入&lt;bean id=&quot;demo&quot; class=&quot;com.xdl.bean.DemoBean&quot;&gt; &lt;property name=“dbParams&quot;&gt; &lt;props&gt; &lt;prop key=&quot;user&quot;&gt;scott&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;tiger&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 引入注入集合 List、Set、Map、Properties集合也可以先 独立定义，再注入的方式使用，这样便于重 复利用。 &lt;util:list id=“subjectList&quot;&gt; &lt;value&gt;php&lt;/value&gt; &lt;value&gt;java&lt;/value&gt; &lt;/util:list&gt; &lt;bean id=“demo&quot; class=&quot;com.xdl.bean.DemoBean&quot;&gt; &lt;property name=“subjects&quot; ref=&quot; subjectList&quot;/&gt; &lt;/bean&gt; Spring表达式注入&lt;util:properties id=“db“ location=&quot;classpath:db.properties&quot;/&gt; &lt;bean id=&quot;demo&quot; class=&quot;com.xdl.bean.OracleDataSource&quot;&gt; &lt;property name=“username&quot; value=&quot;#{db.name}&quot;/&gt; &lt;property name=“password&quot; value=&quot;#{db.password}&quot;/&gt; &lt;property name=“url&quot; value=&quot;#{db.url}&quot;/&gt; &lt;/bean&gt; 组件扫描Spring提供了一套基于注解配置的使用方法。 使用该方法可以大大简化XML配置信息. 开启组件扫描 在applicationContext.xml添加启动标记 &lt;context:component-scan base-package=“包路径”/&gt; 在组件类中添加注解 扫描组件后，默认scope为singleton单例， 也可以进行指定，例如 @component(“empDao”) @Scope(“prototype”) 也可以指定初始化和销毁的方法 例如 @Component public class DemoBean { @PostConstruct public void init() { //初始化回调方法 } @PreDestroy public void destroy() { //销毁回调方法 } } 将所有Bean组件扫描到Spring容器后，可 以使用以下注解指定注入关系@Autowired/@Qualifier 可以处理构造器注入和Setter注入 @Resource 只能处理Setter注入，但大部分情况都是Setter注入 Spring AOP 通知的五大类型1.前置通知aop:before 目标方法调用之前2.后置通知aop:after-returning 目标方法不抛异常,并且执行完才调用3.最终通知aop:after目标方法调用完成调用,但无视异常4.环绕通知aop:around目标方法调用前后都执行5.异常通知aop:after-throwing出现异常才进行通知通知对应的标注: @Before 前置通知 @AfterReturning 后置通知 抛出异常不会执行 @After 最终通知 抛出异常也会执行 @AfterThrowing 异常通知 抛出异常才执行 @Around 环绕通知 切点表达式类型限定表达式within(包名.类名)within(com.xdl.Service.XdlAccountService)限定一个具体的类within(com.xdl.Service.XdlAccount)支持模糊限定within(com.xdl.Service.)代表Service包下所有类型切入切面逻辑within(com.xdl..)多个包的模糊匹配,xdl下的直接子包下类型within(com.xdl..*)xdl下所有包下类型都切入逻辑 方法限定表达式execution(权限 返回值 方法名(参数) 异常)返回值 方法名()必须有!execution( log()) 返回值不受限制 支持模糊查询execution(log(int))返回值不受限制 方法名必须以log开头,参数int类型注意方法名前面可以有包名.类名 bean的id限定bean(容器中组件的id作为匹配的标准,可以使用模糊匹配) Spring DAO DAO(Data Access Object)数据访问对象 Spring DAO为整合JDBC提供了封装，简化了DAO组件的编写 Spring DAO提供了AOP模式的事务处理 Spring DAO提供了统一的异常处理层次，它包装的异常类型DataAccessException 继承自RuntimeException无须显式的捕 获 Spring整合JDBC JDBCTemplate提供的主要方法: queryForInt() queryForObject() query() update() execute()JDBCTemplate配置: Spring事务声明式事务管理Spring声明式事务管理，是使用Spring的 AOP方式实现的 通过Spring配置将操作纳入到事务管理中 解除了事务管理和代码的耦合 不需要事务管理时，可直接从Spring配置文件 中移除 使用步骤 第一步: 在applicationContext.xml中声明事务组件，开启事务注解扫描 &lt;!-- 声明事务管理组件 --&gt; &lt;bean id= &quot;txManager&quot; class= &quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;/&gt; &lt;/bean&gt; &lt;!-- 开启事务注解扫描 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; proxy-target-class=&quot;true&quot;/&gt; 第二步: 使用@Transactional注解声明事务 @Transactional属性 propagation：设置事务传播 默认:REQUIRED isolation：设置事务隔离级别 默认:事务隔离级别是DEFAULT，根据数据库自动选择，Oracle默认READ_COMMITED级别 readOnly：设置为只读，还是可读写 默认readOnly=false rollbackFor：设置遇到哪些异常必须回滚(默认:任何RuntimeException将触发事务回滚，但是任何Checked Exception将不触发事务回滚 ) noRollbackFor：设置遇到哪些异常不回滚 脏读:一个事务读取到了另外一个事务没有提交的数据 不可重复读:一个事务在开始时读取了一份数据,然后再事务操作的过程中另外一个事务修改了这份数据并进行了提交,当第一个事务再次读取这份数据时,发现数据发生了改变. 幻读:一个事务对一张表中的所有数据做了统计,但是这个时候发生了数据的增加,再次统计数据发现数据发生了改变. propagation 事务的传播特性一个方法(可能有也可能没有)调用一个事务方法时的表现 REQUIRED 如果当前方法没有事务,则创建一个事务,如果当前方法有事务则加入到当前事务中. Propagation.MANDATORY 表示该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常 Propagation.NESTED 表示如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像Propagation.REQUIRES一样。 Propagation.NEVER 表示当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常。 Propagation.NOT_SUPPORTED 表示该方法不应该在一个事务中运行。如果一个现有事务正在进行中，它将在该方法的运行期间被挂起。 Propagation.SUPPORTS 表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。 Propagation.REQUIRES_NEW 表示当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起。 Propagation.REQUIRED 表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。 Spring MVC SpringMVC应用结构 将控制器数据传输给页面1 使用request session application等这些域对象传递数据2 使用ModelAndView来进行数据传递,ModelAndView对象可以通过getModel()得到map接口类型模型,也可以通过getModelMap()得到一个ModelMap类型的模型.3 使用ModelMap来传递数据 mm.addattribute(); mm.put(); 4 使用Model 来传递数据5 @ModelAttribute(“abc”)可对复杂对象进行模型key的设置,默认对类名首字母小写之后放入request作用域中. Spring MVC中重定向Spring MVC中默 认对请求进行转发处理,如要实现重定向,则需用以下两种方式1 针对控制器方法 返回String &quot;redirect:重定向路径&quot; 2 针对控制器方法 返回ModelAndView RedirectView rv = new RedirectView(&quot;toMain2.do&quot;); ModelAndView mav = new ModelAndView(); mav.setView(rv); 控制器中的中文参数处理spring中是通过编码过滤器解决的 //注意它只针对post方式 &lt;filter&gt; &lt;filter-name&gt;&lt;/filter-name&gt; &lt;filter-class&gt;&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;&lt;/filter-name&gt; &lt;url-pattern&gt;&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 拦截器实现步骤: 写一个类,先实现HandlerInterceptor接口 配置拦截器 拦截器组下可配置多个拦截器 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/*&quot;&gt;&lt;/mvc:mapping&gt; &lt;bean class=&quot;com.xdl.interceptor.checkLogin&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 多个拦截器的执行顺序preHandler 执行顺序和配置顺序一致其它方法和 配置顺序相反 Spring MVC中的异常处理1 当程序中出现了异常,使用SimpleMappingExceptionResolver来处理,只需要在配置文件中配置这个对象即可 &lt;!--配置出项的异常类型和错误页面之间的对应关系--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.NullPointException&quot;&gt;error1&lt;/prop&gt; &lt;prop key=&quot;java.lang.Exception&quot;&gt;error2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 2 第二种异常处理方案实现HandlerExceptionResolver接口3 局部异常处理针对的是一个具体的控制器,控制之外的异常处理不了@ExceptionHandler加在控制器中的一个自定义方法上 文件上传1 写一个文件上传页面 请求方式:post enctype=&quot;multipart/form-data&quot; 包含文件上传的file组件 2 写文件上传的控制器控制器解析文件上传的请求,需借助MultipartResolver接口实现借助第三方jar包 &lt;!--配置一个文件解析器--&gt; &lt;bean id=&quot;MultipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; RESTREST即表述性状态传递（英文：Representational State Transfer，简称REST） 对请求的URL做了基于资源的设计 对请求方式做了设置 用 GET POST PUT DELETE 代表对应的操作 RESTful基于REST规范的应用程序就是RESTful @PathVariable作用是将URI请求模板中的变量解析出来，映射到处理方法的参数上 RESTful对静态资源放行 DispatcherServlet 对应的url-parttern 改成 / 需要对静态资源放行 &lt;mvc:default-servlet-handler/&gt; Spring ORM MybatisApache开源项目IBatis后迁移给Google code更名为MyBatis可以做SQL操作（增删改DML 查DQL DDL）以及存储过程的调用ORM(对象关系映射 把数据库中的数据变成对象,以及组织对象之间的关系)MyBaties 封装了几乎所有的JDBC操作以及参数的手工设置以及结果集的检索和对象的封装2. Mapper映射器规则1.SQL定义文件中的namespace要和接口的包名.接口名保持一致2.接口中的方法名和sql定义文件中sql语句id保持一致3.方法的参数要和parameterType中规定的一致4.方法的返回值要和resultType保持一致DML(insert delete update)返回值可以是void也可以是intselect语句最多返回单行 方法的返回值类型和resultType一致select语句可返回多行 方法的返回值类型要是List MyBatis应用扩展${}和#{}参数区别 ${}采用Statement机制;#{}采用PrepareStatement预编译SQL执行机制 建议采用#{}，能防止注入式攻击，安全 表名和字段名位置使用${},动态sql;字段值位置使用#{} Mapper映射器多参数映射问题 使用#{param1}、#{param2}… 推荐使用@Param(“key”)然后使用#{key} 自定义类型别名在sqlmap-config.xml中追加定义 &lt;typeAliases&gt; &lt;typeAlias type=&quot;cn.xdl.entity.Dept&quot; alias=&quot;dept&quot;/&gt; &lt;/typeAliases&gt; 开启MyBatis框架日志输出在sqlmap-config.xml中追加定义 &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; MyBatis分页处理 添加pageHelper.jar开发包 在sqlmap-config.xml中追加定义&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;/&gt; &lt;/plugins&gt; 使用方法,在调用Mapper方法查询前执行Page page = PageHelper.startPage(1, 3); List&lt;Dept&gt; list = deptDao.findAll();]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年我学过的SpringBoot笔记]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E6%88%91%E5%AD%A6%E8%BF%87%E7%9A%84SpringBoot%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[maven SpringBoot简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。 SpringBoot的特点（优点） 内置Tomcat，可以直接部署，而不依赖外部Tomcat 简化MAVEN配置，提供一系列工具包集合 spring-boot-starter-web(包含内置tomcat、mvc、restful) spring-boot-starter-jdbc(包含tomcat-jdbc连接池、spring-jdbc功能、JdbcTemplate) spring-boot-starter-aop(包含Spring AOP) spring-boot-starter-test(包含Spring test测试框架) spring-boot-starter-parent(包含spring boot底层通用设置和功能) spring-boot-starter(包含ioc、自动配置、日志功能) 自动配置Spring组件（重要特点） 采用Java配置替代了XML配置（完全取消了XML配置形式） SpringBoot数据库访问 SSO单点登录 基于Token流程:使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端。（服务器采用Redis存储） 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据（基于拦截器） 存储方式客户端采用localStorage存储；服务器采用Redis存储HTML5新特性 localStrorage可以永久存储在客户端 令牌的校验与拦截检测用户发送的令牌是否和服务器存储的一致，是否有效,编写一个拦截器，拦截器调用/user/token进行令牌检测，检测正确后，拦截器放过继续执行请求处理，否则拦截。 分布式服务架构目前主流实现：Dubbo+zookeeper和SpringBoot+Cloud利用上述技术都可以将功能服务分散到不同服务器部署，然后实现服务间通信（调用）。请求–&gt;处理1–&gt;处理2–&gt;响应。意思可以将处理1和处理2做成独立服务分开部署，然后再进行RPC（Dubbo）或HTTP请求和响应模式(Cloud)交互。 Dubbo和Cloud的区别如下： Dubbo和Cloud服务调用机制不同，一个RPC、一个HTTP请求响应 Dubbo一般和zookeeper结合管理服务，Cloud内置集成Eureka管理服务 Cloud提供一套服务管理的完整方案、Dubbo需要跟其他技术集成使用。 Cloud仅用于Rest服务管理、Dubbo是将组件服务化管理 Spring CloudSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。 Spring Cloud Netflix是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。 Spring Cloud Config将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件 Spring Cloud Bus分布式消息队列，是对Kafka, MQ的封装 Spring Cloud Security对Spring Security的封装，并能配合Netflix使用 Spring Cloud Zookeeper对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用 Spring Cloud Eureka Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次封装，主要负责完成微服务架构中的服务治理功能。 项目名称易慕教育平台 应用技术Spring、SpringBoot、Mybatis、Redis、Quartz、Bootstrap、js、JSP、AJAX、Nginx 项目工具MyEclipse、Mysql57、Tomcat8、Jdk1.8、Linux 项目描述本系统的主要作用是为广大用户提供一个在线学习的网络平台，系统主要分为主页展示、用户中心、课程中心、视频中心和在线考试模块！为用户提供了、学员注册登录、在线视频、笔记、问答、评论、收藏等众多功能！本系统主要采用分布式系统架构的方式，运用AJAX的局部请求，局部刷新，为在线用户提供更加高效，快速在线访问，以求提高用户体验！ 个人职责:负责用户的登录注册、课程中心、视频中心 Java项目面试:差异化体现个人能力 能力: 你了解哪些部分,框架的整体(官方网站) 纵向深入了解(了解的部分 底层渲染,连接) 横向扩展了解潜力: 你是怎么解决问题的 你如何举一反三 你怎么优化项目 你如何快速学习 善于总结:SpringBoot 项目: SpringBoot关于SpringBoot 快速搭建项目,使用注解的方式省去了大量XML配置内置Tomcat @RequestMapping@PathVariable@ResponseBody Mybatis关于Mybatis 是对象关系映射配置文件编写xml配置的 update delete等标签在映射文件中编写 @update()注解的方式编写sql语句 git关于git 分布式反版本控制器数据是按照元数据的方式进行存储git使用的是SHA-1 哈希算法 redis关于redis数据存储结构:key-value数据类型:应用场景:缓存 事务 日志 订阅 排序使用:导入jar 开启redis,正常安装的电脑话默认开启,配置redis连接信息 分布式系统 前后端分离的方式什么是分布式系统谈谈你对分布式的理解;前后端分离的历史发展: redis+session共享如何实现的redis和session共享:导入:两个jar包实现的目的 SSO单点登录:单点登录的原理单点登录的优劣 密码加密:使用MD5算法,对密码进行加盐 拦截器:继承HandlerInterceptor接口实现了三个方法,在boolean preHandle方法下验证用户是否登录!进行拦截未登录则跳转登录界面! 推荐查询优化:推荐展示如何优化查询的!用户点击课程进行学习,根据课程id获取到该课程类目的其他课程进行推荐展示 传参的三种方式: 谈谈传统session方式和使用token的区别?你在搭建项目时候遇到的问题,以及你是如何解决的]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[那年我梳理的Java编程题]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%82%A3%E5%B9%B4%E6%88%91%E6%A2%B3%E7%90%86%E7%9A%84Java%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[编程题1.打印九九乘法表（双重for循环）public class TestStudy { /** * 打印九九乘法表 * @param args */ public static void main(String[] args) { for (int i = 1; i &lt;= 9; i++) { for (int j = 1; j &lt;= i; j++) { System.out.print(i+&quot;x&quot;+j + &quot;=&quot; + i*j +&quot; &quot;); } System.out.println(); } } } 2.打印水仙花数 /* 编程实现所有三位数水仙花数的打印 */ public class TestWaterFlower{ public static void main(String[] args){ //1.打印所有的三位数 for(int i = 100; i &lt;= 999; i++){ //2.拆分该三位数中的每个数字 123 int ia = i / 100; //获取百位数 int ib = i % 100 / 10; //获取十位数 int ic = i % 10; //获取个位数 //3.判断i代表的数值是否为水仙花数，若是则打印 if((ia*ia*ia + ib*ib*ib + ic*ic*ic) == i){ System.out.println(i); } } } } 3.数组的增删改查数组增删不便,牵一发而动全身 查找方便,支持下标访问 Arrays.sort(arr);调用方法进行数组排序,底层实现方式是:快速排序 编程实现双色球:package cn.xdl.test; import java.util.Arrays; import java.util.Random; public class TestStudy { public static void main(String[] args) { int[] arr = new int[6]; //调用随机函数 Random random = new Random(); for (int i = 0; i &lt; 6; i++) { //调用随机函数生成1~33之间的随机数并对数组进行赋值 arr[i] = random.nextInt(33)+1; //针对每次生成的随机号码进行去重操作 for (int j = i-1 ; j &gt;=0 ;j--) { //如果有相等,i--重新执行生成操作 if(arr[i] == arr[j]){ i--; break; } } } Arrays.sort(arr);//排序 int red = random.nextInt(16)+1; for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]+&quot; &quot;); } System.out.println(red); } } 编程实现五子棋(控制台版):二维数组package cn.yimu.goband; /* 编程实现控制台版的五子棋游戏，支持两人对战 */ import java.util.Scanner; public class Goband { //自定义二维数组来描述棋盘，默认初始值为0 int[][] chessBoard = new int[16][16]; //自定义成员方法来绘制棋盘 void paint(){ //1.先绘制棋盘中第一行的坐标信息，也就是列坐标信息 for(int i = 0; i &lt; 17; i++){ if(i == 0){ System.out.print(&quot; &quot;); } else{ //按照十六进制的格式打印i-1的数值 System.out.printf(&quot;%x &quot;, i-1); } } System.out.println(); //2.绘制棋盘中除了第一行之外的其他部分以及行坐标信息 for(int i = 0; i &lt; 16; i++){ //用于打印行坐标信息 System.out.printf(&quot;%x &quot;, i); for(int j = 0; j &lt; 16; j++){ //刚开始棋盘中的所有内容都是+，因此直接打印 if(chessBoard[i][j] == 0){ System.out.print(&quot;+ &quot;); } else if(chessBoard[i][j] == 1){ System.out.print(&quot;● &quot;); } else{ System.out.print(&quot;○ &quot;); } } //打印完毕一行的所有内容之后进行换行 System.out.println(); } } //自定义成员方法来提示黑方和白方分别下棋 void play(){ //定义标志位来进行黑方和白方的切换，true代表黑方，false代表白方 boolean flag = true; //不断地分别提示黑方和白方下棋 while(true){ System.out.println(&quot;请&quot; + (flag ? &quot;黑方&quot;: &quot;白方&quot;) + &quot;输入落子坐标(x y)：&quot;); Scanner sc = new Scanner(System.in); int ix = sc.nextInt(); int iy = sc.nextInt(); //根据用户输入的坐标来调整棋盘中的图案，策略为改变数组的元素值 if(flag){ //当黑方落子时就将数组中对应元素值改为1 chessBoard[ix][iy] = 1; }else{ //当白方落子时就将数组中对应元素改为2 chessBoard[ix][iy] = 2; } //重新绘制图案 paint(); //判断当前方是否胜利，若胜利就立刻结束游戏 if(judge(ix, iy)){ System.out.println(&quot;恭喜&quot; + (flag ? &quot;黑方&quot;: &quot;白方&quot;) + &quot;胜利了！&quot;); break; } //此时切换下棋方 flag = !flag; } } //自定义成员方法来判断用户是否获胜，获胜的规则是：任意相同颜色的5个棋子连成一线 boolean judge(int ix, int iy){ //1.判断竖向是否连成一线，则需要以该点为中心向上四个点向下四个点 //声明变量来统计竖向相同颜色棋子的个数，先统计向上同色棋子的个数 int count = 1; for(int i = ix-1; i &gt;= 0 &amp;&amp; i &gt;= ix-4; i--){ //若当前点代表的棋子与上述某个点代表的棋子不一样，则向上统计结束 if(chessBoard[ix][iy] != chessBoard[i][iy]){ break; } count++; } System.out.println(&quot;count1 = &quot; + count); //再统计向下颜色相同的个数 for(int i = ix+1; i &lt;= 15 &amp;&amp; i &lt;= ix+4; i++){ if(chessBoard[ix][iy] != chessBoard[i][iy]){ break; } count++; } System.out.println(&quot;count2 = &quot; + count); //... ... return count &gt;= 5; //当所有可能胜利的情况都排除了，那么肯定是失败了 } } 启动类: public class TestGoband { public static void main(String[] args) { //1.声明一个GoBand类型的引用指向该类的对象 Goband gb = new Goband(); //2.调用成员方法来绘制棋盘 gb.paint(); //3.调用成员方法来进行下棋 gb.play(); } } 4.递归方法的调用所谓递归就是自己调用自己的方法:递归有可能会大幅简化代码的编写。递归要考虑性能问题，有些时候可以使用循环而不是递归。递归的使用原则:1 必须有退出条件。2 必须使问题变简单，而不是复杂化。 递归方式实现阶乘:public class TestDG { /** * 自定义算法实现阶乘 * 阶乘:1*2*3*4...*n * @param n * @return */ int factorial(int n){ if(n == 1){ return 1; } return n*factorial(n-1); } public static void main(String[] args) { TestDG dg = new TestDG(); System.out.println(dg.factorial(4)); } } 费时数列的递归实现public class TestDG { /** * 自定义递归实现费式数列 * 费式数列:也叫斐波那契数列:即从1开始,后一个数等于前两个数之后1、1、2、3、5、8、13、21... * @return */ int sequence(int n){ if(n == 1 || n == 2){ return 1; } return sequence(n-1)+sequence(n-2); } public static void main(String[] args) { TestDG dg = new TestDG(); System.out.println(dg.sequence(45)); } } 5.单例设计模式（饿汉式，懒汉式）饿汉式: public class Singleton(){ //1 私有化构造方法 private Singleton(){} //2 提供一个本类类型的引用指向本类的对象 private static Singleton sin = new Singleton(); //3 提供一个公用的方法将sin的数值返回出去 public static Singleton getInstance(){ return sin; } }懒汉式: public calss Singleton(){ private Singleton(){}; private static Singleton sin = null; public static Singleton getInstance(){ if(sin == null){ sin = new Singleton(); } return sin; } } 6.匿名内部类Thread th = new Thread(){ 编写代码; }; 7.自定义异常类自定义异常类:继承自Exception public class AgeException extends Exception{ 编写代码; } 8.递归实现多层文件读取文件名import java.io.File; public class PrintList { /** * 自定义方法打印参数指定目录及其子目录中的文件 * @param file */ public static void print(File file){ // 判断是否是普通文件 if(file.isFile()){ System.out.println(file.getName()); }else if(file.isDirectory()){ //获取目录中的所用内容 File[] fArr = file.listFiles(); //使用递归,打印所有 for (File f: fArr) { print(f); } } } public static void main(String[] args) { File file = new File(&quot;目录或者文件名&quot;); PrintList.print(file); } } 9.使用byte[] 实现文件的拷贝import java.io.FileInputStream; import java.io.FileOutputStream; public class FileCopy { public static void main(String[] args) { try { //文件流对象,关联需要拷贝文件 FileInputStream fis = new FileInputStream(&quot;输出文件名&quot;); FileOutputStream fos = new FileOutputStream(&quot;输入文件名&quot;); //准备一个合理的缓存区,每次只需要将缓存区写满再写入 byte[] brr = new byte[1024*8]; int res =0; while((res = fis.read(brr)) != -1){ fos.write(brr,0,res); } fis.close(); fos.close(); } catch (Exception e) { e.printStackTrace(); } } } 10.多线程的实现方式（扩展）方式一:继承Thread类 /** * 1 继承Thread类 * 2 重写run方法 * 3 调用start()开启线程 * @author liangmu */ public class WayThread extends Thread{ @Override public void run(){ for (int i = 0; i &lt; 26; i++) { System.out.println(&quot;线程一:&quot; + i); } } public static void main(String[] args) { Thread th = new WayThread(); th.start();//启动一个线程的方法 for (int i = 0; i &lt; 21; i++) { System.out.println(&quot;main线程:&quot;+ i); } } } 方式二:实现Runnable接口 /** * 方式二 * 1 实现Runnable接口 * 2 重写run方法 * 3 开启线程 * @author liangmu * */ public class WayThread implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(&quot;子线程:&quot; + i); } } public static void main(String[] args) { Runnable ra = new WayThread(); Thread th = new Thread(ra); th.start(); for (int i = 0; i &lt; 100; i++) { System.out.println(&quot;主线程方法:&quot; + i); } } } 方式三:匿名内部类 /** * 方式三: * 使用匿名内部类的方式调用 * @author liangmu * */ public class WayThread{ public static void main(String[] args) { Thread th = new Thread(){ public void run(){ for (int i = 0; i &lt; 30; i++) { System.out.println(&quot;线程一&quot; + i); } } }; th.start(); new Thread(){ public void run(){ for (int i = 0; i &lt; 30; i++) { System.out.println(&quot;线程二&quot; + i); } } }.start(); } } 11.基于TCP协议的网络编程（UDP协议 扩展）客户端: public class TestClient { public static void main(String[] args) { try{ //1.创建Socket类型的对象，并提供服务器的IP地址和端口号 Socket s = new Socket(&quot;localhost&quot;, 8888); //2.使用输入输出流进行通信 PrintStream ps = new PrintStream(s.getOutputStream()); BufferedReader br = new BufferedReader( new InputStreamReader(s.getInputStream())); Scanner sc = new Scanner(System.in); while(true){ //String msg = &quot;在吗？&quot;; System.out.println(&quot;请输入要发送的内容：&quot;); String msg = sc.nextLine(); ps.println(msg); System.out.println(&quot;发送数据成功！&quot;); //判断客户端给服务器发送的内容是否为&quot;bye&quot; if(&quot;bye&quot;.equalsIgnoreCase(msg)){ System.out.println(&quot;再见吧！&quot;); break; } //接收服务器回发的消息 String str = br.readLine(); System.out.println(&quot;服务器发来的数据是：&quot; + str); } //3.关闭Socket并释放有关的资源 br.close(); ps.close(); s.close(); }catch(Exception e){ e.printStackTrace(); } } } 服务端: import java.net.ServerSocket; import java.net.Socket; public class TestServer { public static void main(String[] args) { try { //创建ServerSocket类型的对象,并提供端口号 ServerSocket ss = new ServerSocket(8888); while(true){ System.out.println(&quot;等待客户端连接请求...&quot;); Socket s = ss.accept(); System.out.println(s.getInetAddress()+&quot;连接成功&quot;); ServerThread thread = new ServerThread(s); Thread th = new Thread(thread); th.start(); } } catch (Exception e) { e.printStackTrace(); } } } 线程: public class ServerThread implements Runnable{ private Socket s; public ServerThread(Socket s){ this.s = s; } @Override public void run(){ try{ //3.使用输入输出流进行通信 BufferedReader br = new BufferedReader( new InputStreamReader(s.getInputStream())); PrintStream ps = new PrintStream(s.getOutputStream()); while(true){ String str = br.readLine(); System.out.println(&quot;客户端&quot; + s.getInetAddress() + &quot;发来的数据是：&quot; + str); //判断客户端发来的数据是否为&quot;bye&quot;，若是则结束通信 if(&quot;bye&quot;.equalsIgnoreCase(str)){ System.out.println(&quot;话不投机半句多！客户端&quot; + s.getInetAddress() + &quot;已下线！&quot;); break; } //实现服务器向客户端回发消息 ps.println(&quot;I received!&quot;); System.out.println(&quot;服务器发送数据成功！&quot;); } //4.关闭Socket并释放有关的资源 ps.close(); br.close(); s.close(); }catch(Exception e){ e.printStackTrace(); } } } 12.冒泡算法(快速算法 扩展)public class TestSort(){ public static void bubble(int[] arr){ //1.使用外层for循环来控制比较的轮数 for(int i=1;i&lt;arr.length;i++){ boolean flag = true;//打标记 //2.使用内层for循环来控制每一轮中比较的次数，也就是j的取值范围 for(int j=0;j&lt;arr.length-i;j++){ //3.若左边的元素比右边的元素大，则交换两个元素的位置 if(arr[j]&gt;arr[j+1]){ int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = false; } } if(flag) break; } } public static void main(String[] args){ int[] arr = {12,32,25,2,6,86,63,21,15,36}; TestSort.bubble(arr); for(int i=0;i&lt;arr.length;i++){ System.out.println(arr[i]); } } } 13.工厂模式 抽象工厂模式(23种设计模式 扩展)设计模式: 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式本质上就是一种固定的套路，使用在固定的场合中。 分类:创建型模式 - 工厂方法模式、抽象工厂模式、单例设计模式。结构型模式 - 装饰器模式、代理模式。行为型模式 - 模板设计模式、观察者模式。 1、工厂方法模式（Factory Method）:普通工厂模式:(邮件和短信的例子)接口: public interface Sender{ public void send(); } 接口实现类: public class MailSender implements Sender { @Override public void send() { System.out.println(&quot;邮件发送&quot;); } } public class SmsSender implements Sender { @Override public void send() { System.out.println(&quot;信息发送&quot;); } } 工厂类: public class SendFactory { //工厂方法 public Sender produce(String type){ if (&quot;mail&quot;.equals(type)) { return new MailSender(); } else if (&quot;sms&quot;.equals(type)) { return new SmsSender(); } else { System.out.println(&quot;请输入正确的类型!&quot;); return null; } } } 工厂测试类: public class TestFactory { public static void main(String[] args) { SendFactory sendFactory = new SendFactory(); Sender sms = sendFactory.produce(&quot;sms&quot;); sms.send(); } } 多个工厂方法模式: 即在工厂类中添加多个工厂方式静态工厂方法模式: 即将工厂类中的方法设置为静态的加static,不需要创建实例,可直接调用 抽象工厂模式工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码 ![](https://i.imgur.com/DnyYVD1.png) 接口: 实现类: 工厂类实现接口方法: 测试类: 14.学生信息管理系统c/s架构编写,SE阶段最具代表性的项目]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nosql进阶笔记之redis MongoDB]]></title>
    <url>%2F2018%2F11%2F11%2FNosql%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%E4%B9%8Bredis%20MongoDB%2F</url>
    <content type="text"><![CDATA[Nosql简介NoSQL指的是非关系型的数据库。其实，NoSQL概念最早出现在1998年，当时的含义是反SQL技术革命运动，但并未引起太多的关注。直到2009年，NoSQL概念被来自Rackspace的EricEvans再次提出，这时的NoSQL已经不是单纯的反SQL运动，指的主要是非关系型的分布式数据库，并且不支持原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)的数据库设计模式。在亚特兰大举行的有关NoSQL的讨论会上，学者给出了NoSQL较为普遍的解释，即“非关系型的”。并且指出Key-Value存储和文档数据库是NoSQL的主要特点。 特点1：key-value存储2：最终一致性3：可拓展 NoSQL和关系型数据库关系型数据库优势: 1.擅长小数据量的处理 2.擅长复杂的SQL操作,可以进行Join等复杂查询 3.可以方便的生成各种数据对象，利用存储的数据建立窗体和报表，可视性好 劣势： 1.很难进行分布式应用和大量数据的写入处理 2.为有数据更新的表做索引和结构变更 3.字段不固定的应用 4.对简单查询需要快速返回结果的处理 NoSQL数据库优势: 1.擅长大量数据的写入和读取 2.快速的查询响应,灵活的数据模型 3.数据结构变更或更新非常方便，不需要更改已有数据的数据结构 4.击碎了性能瓶颈，可以使执行速度变的更快 劣势: 1.不提供复杂的API接口 2.一般仅提供key索引 3.不适合小数据的处理 4.现有产品的不够成熟,大多数产品都还处于初创期 NoSQL 数据库分类 Redis简介Redis（REmote DIctionary Server）是一个开源的使用ANSI C语言编写、是一个由Salvatore Sanfilippo写的key-value存储系统，支持网络、可基于内存亦可持久化的日志型、并提供多种语言的API。Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis优点 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis数据类型string(字符串)string是redis最基本的类型，而且string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象从内部实现来看其实string可以看作byte数组，最大上限是1G字节string类型的值也可视为integer，从而可以让“incr”命令族操作，这种情况下，该integer的值限制在64位有符号数在list、set和zset中包含的独立的元素类型都是string类型应用场景：String是最常用的一种数据类型,普通的key/value存储. list(双向链表)redis的list类型其实就是一个每个子元素都是string类型的双向链表，所以[lr]push和[lr]pop命令的算法时间复杂度都是O(1)，另外list会记录链表的长度，所以llen操作也是O(1).可以通过push,pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列list的最大长度是2^32-1个元素应用场景：Redis list应用场景非常多,也是Redis最重要的数据结构之一,比如twitter的关注列表,粉丝列表等都可以用Redis的list结构来实现. set(无序集合)set就是redis string的无序集合，不允许有重复元素set的最大元素数是2^32-1对set的操作还有交集、并集、差集等应用场景：Set对外提供的功能与list类似,当你需要存储一个列表数据,又不希望出现重复数据时,set 是一个很好的选择,并且set提供了判断某个成员是否在一个set集合内的接口,这个也是list所不能提供的 Sorted set(有序集合)– zsetzset是set的一个升级版本，在set的基础上增加了一个顺序属性，这一属性在添加修改元素时可以指定，每次指定后zset会自动安装指定值重新调整顺序。可以理解为一张表，一列存value，一列存顺序。操作中的key理解为zset的名字。zset的最大元素数是2^32-1。对于已经有序的zset，仍然可以使用sort命令，通过指定asc|desc参数对其进行排序。应用场景：Sorted set的使用场景与set类似,区别是set不是自动有序的,而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序,并且是插入有序的,即自动排序.当你需要一个有序的并且不重复的集合列表,那么可以选择sorted set数据结构 hash(hash表)redis Hash类型对数据域和值提供了映射，这一结构很方便表示对象在Hash中可以只保存有限的几个“域”，而不是将所有的“域”作为key，这可以节省内存 常见命令Value操作命令exists(key)：确认一个key是否存在 del(key)：删除一个key type(key)：返回值的类型 keys(pattern)：返回满足给定pattern的所有key randomkey：随机返回key空间的一个 keyrename(oldname, newname)：重命名key dbsize：返回当前数据库中key的数目 expire：设定一个key的活动时间（s） ttl：获得一个key的活动时间 select(index)：按索引查询 move(key, dbindex)：移动当前数据库中的key到dbindex数据库 flushdb：删除当前选择数据库中的所有key flushall：删除所有数据库中的所有key string操作的命令set(key, value)：给数据库中名称为key的string赋予值value get(key)：返回数据库中名称为key的string的value getset(key, value)：给名称为key的string赋予上一次的value mget(key1, key2,…, key N)：返回库中多个string的value setnx(key, value)：添加string，名称为key，值为value setex(key, time, value)：向库中添加string，设定过期时间time mset(key N, value N)：批量设置多个string的值 msetnx(key N, value N)：如果所有名称为key i的string都不存在 incr(key)：名称为key的string增1操作 incrby(key, integer)：名称为key的string增加integer decr(key)：名称为key的string减1操作 decrby(key, integer)：名称为key的string减少integer append(key, value)：名称为key的string的值附加value substr(key, start, end)：返回名称为key的string的value的子串 对List操作的命令 rpush(key, value)：在名称为key的list尾添加一个值为value的元素 lpush(key, value)：在名称为key的list头添加一个值为value的 元素 llen(key)：返回名称为key的list的长度 lrange(key, start, end)：返回名称为key的list中start至end之间的元素 ltrim(key, start, end)：截取名称为key的list lindex(key, index)：返回名称为key的list中index位置的元素 lset(key, index, value)：给名称为key的list中index位置的元素赋值 lrem(key, count, value)：删除count个key的list中值为value的元素 lpop(key)：返回并删除名称为key的list中的首元素 rpop(key)：返回并删除名称为key的list中的尾元素 blpop(key1, key2,… key N, timeout)：lpop命令的block版本。 brpop(key1, key2,… key N, timeout)：rpop的block版本。 rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 对Set操作的命令sadd(key, member)：向名称为key的set中添加元素member srem(key, member) ：删除名称为key的set中的元素member spop(key) ：随机返回并删除名称为key的set中一个元素 smove(srckey, dstkey, member) ：移到集合元素 scard(key) ：返回名称为key的set的基数 sismember(key, member) ：member是否是名称为key的set的元素 sinter(key1, key2,…key N) ：求交集 sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合 sunion(key1, (keys)) ：求并集 sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合 sdiff(key1, (keys)) ：求差集 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合 smembers(key) ：返回名称为key的set的所有元素 srandmember(key) ：随机返回名称为key的set的一个元素 对Hash操作的命令hset(key, field, value)：向名称为key的hash中添加元素field hget(key, field)：返回名称为key的hash中field对应的value hmget(key, (fields))：返回名称为key的hash中field i对应的value hmset(key, (fields))：向名称为key的hash中添加元素field hincrby(key, field, integer)：将名称为key的hash中field的value增加integer hexists(key, field)：名称为key的hash中是否存在键为field的域 hdel(key, field)：删除名称为key的hash中键为field的域 hlen(key)：返回名称为key的hash中元素个数 hkeys(key)：返回名称为key的hash中所有键 hvals(key)：返回名称为key的hash中所有键对应的value hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value Redis功能Redis发布/订阅Redis的发布/订阅(Publish/Subscribe)功能类似于传统的消息路由功能,发布者发布消息,订阅者接收消息,沟通发布者和订阅者之间的桥梁是订阅的Channel或者Pattern.订阅者和发布者之间的关系是松耦合的,发布者不指定哪个订阅者才能接收消息,订阅者不只接收特定发布者的消息. Redis事务支持Redis目前对事务支持还比较简单,也即支持一些简单的组合型的命令,只能保证一个client发起的事务中的命令可以连续的执行,而中间不会插入其他client的命令. 由于Redis是单线程来处理所有client的请求的所以做到这点是很容易的.事务的执行过程中,如果redis意外的挂了,这时候事务可能只被执行了一半,可以用redis-check-aof 工具进行修复 Redis主从复制(集群)Master/Slave配置: Master IP:175.41.209.118 Master Redis Server Port:6379 Slave配置很简单,只需要在slave服务器的redis.conf加入: slaveof 175.41.209.118 6379 启动master和slave,然后写入数据到master,读取slave,可以看到数据被复制到slave了. 用途:读写分离,数据备份,灾难恢复等 Redis主从复制过程:配置好slave后,slave与master建立连接,然后发送sync命令. 无论是第一次连接还是重新连接,master都会启动一个后台进程,将数据库快照保存到文件中,同时master主进程会开始收集新的写命令并缓存. 后台进程完成写文件后,master就发送文件给slave,slave将文件保存到硬盘上,再加载到内存中。 接着master就会把缓存的命令转发给slave,后续master将收到的写命令发送给slave. 如果master同时收到多个slave发来的同步连接命令,master只会启动一个进程来写数据库镜像, 然后发送给所有的slave Redis主从复制特点： master可以拥有多个slave. 多个slave可以连接同一个master外,还可以连接到其他slave. 主从复制不会阻塞master,在同步数据时,master可以继续处理client请求. 可以在master禁用数据持久化,注释掉master配置文件中的所有save配置,只需在slave上配置数据持久化. 提高系统的伸缩性 Redis主从复制速度： 官方提供了一个数据, 㻿lave在21秒即完成了对Amazon网站 10G key set的复制. Redis持久化由于Redis是内存数据库，它将自己的数据库状态存储在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器退出，服务器中的数据库状态也会消失不见。为了解决这个问题，Redis提供了RDB、AOF持久化方式，将内存中的数据保存到磁盘中，避免数据意外丢失 （1）RDB是 Snapshotting（快照）也是默认方式： 快照是默认的持久化方式。这种方式将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。可以配置自动做快照持久 化的方式。我们可以配置redis在n秒内如果超过m个key被修改就自动做快照RDB持久化通过将服务器某个时间点上的数据库状态（非空数据库以及相关键值对）保存到一个RDB文件中，Redis服务器可以用它来还原数据库状态。 SAVE命令会阻塞Redis服务器进程。而BGSAVE会派生出一个子进程，然后由子进程负责创建RDB文件，服务器父进程继续处理命令请求。还可以SAVE命令设置自动间隔保存， 例如SAVE 60 10000 服务器在60秒之内，对数据库进行了至少10000次修改，自动执行BGSAVE命令。RDB文件是一个经过压缩的二进制文件。 （2）AOF(Append-only file)： AOF持久化通过保存Redis服务器所执行的写命令来记录数据库状态的。被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，Redis的命令请求协议保存为纯文本格式。AOF持久化功能的实现分为命令追加、文件写入、文件同步三个步骤：当AOF持久化处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令（如SET、SADD、RPUSH）追加到服务器状态的aofbuf缓冲区的末尾。服务器在每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值（ always 、 everysec（默认） 、 no ）来决定 RDB与AOF比较RDB 优点：RDB 是一个非常紧凑的文件，它保存了 Redis 在某个时间点上的数据集。这种文件非常适合用于进行备份。缺点：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态，所以它并不是一个轻松的操作。因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。 AOF 优点：使用 AOF 持久化会让 Redis 变得非常耐久：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。缺点：对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 Java操作Redis导入jar包&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 连接操作Jedis jd = new Jedis(&quot;39.106.131.203&quot;); MongoDBMongoDB简介MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引 MongoDB特点 面向集合存储，易于存储对象类型的数据 模式自由 支持动态查询 支持完全索引，包含内部对象 支持查询 支持复制和故障恢复 使用高效的二进制数据存储，包括大型对象（如视频等） 自动处理碎片，以支持云计算层次的扩展性 支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序 文件存储格式为 BSON（一种 JSON 的扩展）,文档型可通过网络访问 面向集合（Collenction-Orented）意思是数据被分组存储在数据集中，被称为一个集合（Collenction)。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定义任何模式（schema) 模式自由（schema-free)意味着对于存储在 MongoDB 数据库中的文件，我们不需要知道它的任何结构定义。提了这么多次”无模式”或”模式自由”，它到是个什么概念呢？ 例如，下面两个记录可以存在于同一个集合里面：{“welcome” : “Beijing”}{“age” : 25} 文档型:意思是我们存储的数据是键-值对的集合,键是字符串,值可以是数据类型集合里的任意类型,包括数组和文档. 我们把这个数据格式称作 “BSON” 即 “Binary Serialized dOcument Notation.” 体系结构MongoDB 是一个可移植的数据库，它在流行的每一个平台上都可以使用，即所谓的跨平台特性。在不同的操作系统上虽然略有差别，但是从整体构架上来看，MongoDB 在不同的平 台上是一样的，如数据逻辑结构和数据的存储等等。一个运行着的 MongoDB 数据库就可以看成是一个 MongoDB Server，该 Server 由实例和数据库组成，在一般的情况下一个 MongoDB Server 机器上包含一个实例和多个与之对应的数据库，但是在特殊情况下，如硬件投入成本有限或特殊的应用需求，也允许一个 Server 机器上可以有多个实例和多个数据库。MongoDB 中一系列物理文件（数据文件，日志文件等）的集合或与之对应的逻辑结构（集 合，文档等）被称为数据库，简单的说，就是数据库是由一系列与磁盘有关系的物理文件的 组成。 数据逻辑结构 MongoDB 的逻辑结构是一种层次结构。主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。 1： MongoDB 的文档（document），相当于关系数据库中的一行记录 2：多个文档组成一个集合（collection），相当于关系数据库的表 3：多个集合（collection），逻辑上组织在一起，就是数据库（database） 4：一个 MongoDB 实例支持多个数据库（database） 数据存储结构 MongoDB 的默认数据目录是/data/db，它负责存储所有的 MongoDB 的数据文件。在 MongoDB内部，每个数据库都包含一个.ns 文件和一些数据文件，而且这些数据文件会随 mongod参数说明mongod 的主要参数有： dbpath: 数据文件存放路径，每个数据库会在其中创建一个子目录，用于防止同一个实例多次运行的 mongod.lock 也保存在此目录中。 logpath 错误日志文件 logappend 错误日志采用追加模式（默认是覆写模式） bind_ip 对外服务的绑定 ip，一般设置为空，及绑定在本机所有可用 ip 上，如有需要可以单独指定 port 对外服务端口。Web 管理端口在这个 port 的基础上+1000 fork 以后台 Daemon 形式运行服务 journal 开启日志功能，通过保存操作日志来降低单机故障的恢复时间，在 1.8 版本后正式加入，取代在 1.7.5 版本中的 dur 参数。 syncdelay 系统同步刷新磁盘的时间，单位为秒，默认是 60 秒。 directoryperdb 每个 db 存放在单独的目录中，建议设置该参数。与 MySQL 的独立表空间类似maxConns最大连接数 repairpath 执行 repair 时的临时目录。在如果没有开启 journal，异常 down 机后重启，必须执行 repair 操作 常见命令show dbs:显示数据库列表 show collections：显示当前数据库中的集合（类似关系数据库中的表） show users：显示用户 use &lt;db name&gt;：切换当前数据库，这和MS-SQL里面的意思一样 db.help()：显示数据库操作命令，里面有很多的命令 db.foo.help()：显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令 db.foo.find()：对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据） db.foo.find( { a : 1 } )：对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1 MongoDB没有创建数据库的命令，但有类似的命令。 修复当前数据库 db.repairDatabase(); 查看当前使用的数据库 db.getName(); db; db和getName方法是一样的效果，都可以查询当前使用的数据库 显示当前db状态 db.stats(); 当前db版本 db.version(); 查看当前db的链接机器地址 db.getMongo(); 基本操作查询文档 添加文档db.users.insert({ “_id”:ObjectId(&quot;52c3c518498a9646a48133a2&quot;), “name”:“likang”, “email”:“likang@qq.com” }); db.users.save({ “_id”:ObjectId(&quot;52c3c518498a9646a48133a2&quot;), “name”:“likang2”, “email”:“likang2@qq.com” }); insert 当_id存在时报错 save 当_id存在时覆盖更新 删除文档//删除全部 db.user.remove(); //删除指定记录 db.user.remove({“name”:“likang”}); //删除user集合 db.user.drop(); 更新文档原文档： { “_id”:ObjectId(&quot;52c3c518498a9646a48133a2&quot;), “name”:“likang”, “email”:“likang@qq.com” } ! 修改后的⽂档： { “_id”:ObjectId(&quot;52c3c518498a9646a48133a2&quot;), “name”:“likang”, “email”:[ “likang@qq.com”, “likang2@qq.com” ] } var doc = db.users.findOne({&quot;name&quot; : “likang”}); doc.email =[ “likang@qq.com”, “likang2@qq.com” ]; db.users.update({ &quot;name&quot; : &quot;likang&quot; }, doc); // 更新:指定第三个参数为true可以开启upsert模式 //根据条件查找不到数据则创建⼀条新的 db.users.update({ &quot;name&quot; : &quot;likang&quot; }, doc, true); 常用工具集MongoDB 在 bin 目录下提供了一系列有用的工具，这些工具提供了 MongoDB 在运维管理上的方便。 bsondump: 将 bson 格式的文件转储为 json 格式的数据 mongo: 客户端命令行工具，其实也是一个 js 解释器，支持 js 语法 mongod: 数据库服务端，每个实例启动一个进程，可以 fork 为后台运行 mongodump/ mongorestore: 数据库备份和恢复工具 mongoexport/ mongoimport: 数据导出和导入工具 mongofiles: GridFS 管理工具，可实现二制文件的存取 -mongos: 分片路由，如果使用了 sharding 功能，则应用程序连接的是 mongos 而不是 mongod mongosniff: 这一工具的作用类似于 tcpdump，不同的是他只监控 MongoDB 相关的包请求，并且是以指定的可读性的形式输出 mongostat: 实时性能监控工具 Java操作MongoDB配置所需jar包&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; 连接Mongodb工具类public class MongoDbUtil { private static MongoCollection&lt;Document&gt; collection; /** * 链接数据库 * * @param databaseName 数据库名称 * @param collectionName 集合名称 * @param hostName 主机名 * @param port 端口号 */ public static void connect(String databaseName, String collectionName,String hostName, int port) { @SuppressWarnings(&quot;resource&quot;) MongoClient client = new MongoClient(hostName, port); MongoDatabase db = client.getDatabase(databaseName); collection = db.getCollection(collectionName); System.out.println(collection); } 应用场景 redis：数据量较小的更性能操作和运算上。 memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能(适合读多写少，对于数据量比较大，可以采用sharding)。MongoDB:主要解决海量数据的访问效率问题。]]></content>
      <categories>
        <category>你那么努力总得给自己留点记忆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下数据库mysql8.0安装]]></title>
    <url>%2F2018%2F11%2F11%2Fwin10%E4%B8%8Bmysql8.0%2F</url>
    <content type="text"><![CDATA[Windos下配置安装Mysql8.0 下载地址：https://dev.mysql.com/downloads/mysql/ 配置Mysql环境变量：win10在系统变量path中新建添加自己mysql的bin目录地址，win7自行英文冒号 安装命令：以管理员的身份打开cmd窗口跳转路径到mysql-8.0.13-winx64\bin 初始化命令 mysqld --initialize --console 执行该操作需要删除mysql下的data目录 初始化完成之后，会生成一个初始密码,下图红色箭头部分 初始密码用于初次登陆进行更改密码 进行服务的安装 mysqld -install 启动服务 net start mysql 登陆mysql，密码是上面的临时密码 mysql -u root -p 修改密码语句:修改密码为：123456，可自行设置 ALTER USER root@localhost IDENTIFIED BY &apos;123456&apos;; 如果安装中出现错误可使用命令删除mysql服务,进行重安装 sc delete mysql 使用mysql8.0中遇到的坑一 驱动地址发生改变由原来的driverClassName: com.mysql.jdbc.Driver变成下面所示 driverClassName: com.mysql.cj.jdbc.Driver 二 需要在url之后配置useSSL和serverTimezone url: jdbc:mysql://localhost/ovls?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false]]></content>
      <categories>
        <category>工欲善其事 必先利其器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库可视化工具Navicat激活]]></title>
    <url>%2F2018%2F11%2F11%2FNavicat%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[Navicat破解之前一直用的是SQLyog最近下载了Navicat for Mysql 12 视觉感很好,用了之后相信你一定会喜欢的！ step01:获取破解文件本人独家分享:链接：https://pan.baidu.com/s/147niPyQnBeyFCfEe-WMZnA 密码：cqty step02:path,path之后断网 step03:相关设置,生成key step04:记得断网,手动激活,拷贝请求码,生成激活码]]></content>
      <categories>
        <category>工欲善其事 必先利其器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MyEclipse&IDEA安装 激活]]></title>
    <url>%2F2018%2F11%2F11%2FMyEclipse%26IDEA%E5%AE%89%E8%A3%85%20%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[Java环境安装JDK8–&gt;打开我的电脑–&gt;属性–&gt;高级环境设置–&gt;环境变量–&gt;系统变量新建: JAVA_HOME—JDK目录地址path中添加: %JAVA_HOME%\bin也可以直接在path中添加bin目录地址 最新版MyEclipse2018.8破解破解文件下载,内含破解方法https://download.csdn.net/download/ym_ily/10599504破解方法和之前版本略有差异内含破解文件 破解方法文档自己看,写的很想详细跟之前2017版本的有一些差别在第六步那儿没有积分的同学 百度网盘下载 提取码： qk9l永久有效 体验感受最新版的MyEclipse,使用了几天总体感觉,程序的流畅度比之前的版本有很大提升!智能化程度也提高了不少!使用起来的话和IDEA感觉差不多了!如何习惯用Eclipse的话新版本确实是一个很不错的选择!毕竟我用IDEA还是适应了一段时间的,快捷键什么的到现在还需要百度,毕竟公司用的是MyEclipse IDEA &amp;&amp; webStorm永久激活点击该网址 http://idea.lanyus.com/ 下载破解补丁 配置破解信息IDEA||WebStorm 的破解方法和步骤都是一样的这个没有什么好多说的,以后换新版了什么的记住上面的那个网址就行了破解文件也放在bin目录下,bin目录下找到 分别编辑两个.vmoptions后缀文件,在最后添加如下图信息 -javaagent:D:\Development\IntelliJ IDEA 2018.2\bin\JetbrainsCrack-2.10-release-enc.jar 编辑好后启动程序从上面的网址中获取注册码激活也可以使用下面的代码激活 ThisCrackLicenseId-{ &quot;licenseId&quot;:&quot;ThisCrackLicense&quot;, &quot;licenseeName&quot;:&quot;your name&quot;, &quot;assigneeName&quot;:&quot;your name&quot;, &quot;assigneeEmail&quot;:&quot;your email&quot;, &quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;, &quot;checkConcurrentUse&quot;:false, &quot;products&quot;:[ {&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;}, {&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;} ], &quot;hash&quot;:&quot;2911276/0&quot;, &quot;gracePeriodDays&quot;:7, &quot;autoProlongated&quot;:false}]]></content>
      <categories>
        <category>工欲善其事 必先利其器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MyEclipse IDEA安装 激活Jrebel]]></title>
    <url>%2F2018%2F11%2F11%2FJREbel%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MyEclipse IDEA通用最新破解方法网上看到很多过于老旧的方法很多不能用建议看到直接pass JRebel的安装在MyEclipse 在help里面找到Eclipse Marketplace Eclipse搜索Jrebel直接下载MyEclipse 中需要搜索下面这个插件进行安装 重启Myeclipse后选择如下图按钮安装 InterlliJIDEA直接在setting中找到plugin点进去搜索下载 关于激活一 反代工具下载使用MyEclipse和IDEA的激活方式几乎一样的,这里主要介绍的是IDEA的破解方式 地址: https://github.com/ilanyu/ReverseProxy/releases/tag/v1.0 根据自己的系统进行选择下载反代工具 下载完成之后直接运行工具,并保持开启状态打开所在编辑工具找到,如下图激活界面 http://xxx.com:8888/88414687-3b91-4286-89ba-2dc813b107ce 将xxx改为自己本地地址随便输入一个邮箱进行激活 激活之后选择离线 二 反代失败解决方案授权地址增加了GUID检测使用 http://xxx.com:8888/jrebelusername 这样的地址无法激活了需要修改为 http://xxx.com:8888/88414687-3b91-4286-89ba-2dc813b107ce 这样的地址如：http://192.168.123.12:8888/88414687-3b91-4286-89ba-2dc813b107ce后面的那串为GUID，网上随便搜索GUID找个GUID在线生成器生成个就行了从老版本升级到该版本的不受影响，激活后一定手动要切换到离线模式，可离线180天，可随时重点下，180天周期会重新刷新 三 使用将时间设置为1s 将选择需要热启动的项目]]></content>
      <categories>
        <category>工欲善其事 必先利其器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo&github搭建博客Next主题]]></title>
    <url>%2F2018%2F11%2F11%2FHexo%26github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言工作学习中难免会遇到一些问题,有些问题比较复杂,第一遇到了百度许久,第二次遇到了还是要百度许久!想想倒不如遇到问题记下来写在博客上!以后好查阅.在CSDN上面看到hexo+github可以免费搭建博客,于是就自己动手搭建了一下,写下来跟大家分享下!本机默认windows系统下准备工作 安装git关于Git:Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git下载地址：https://git-scm.com/downloads 安装步骤:默认下一步 这里选择如图选项，会使得Git安装程序在系统PATH中加入Git的相关路径，这样你可以在CMD界面下调用Git，不用打开Git Bash 安装完成查看版本 git --version 安装完成可以使用鼠标右键点击空白区域,调用 Git Bash 关于HexoHexo是高效的静态站点生成框架，基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势 搭建Node.js环境 由于Hexo框架基于Node.js,使用前先搭建Node.js环境 下载地址：http://nodejs.cn/download (说明：LTS为长期支持版，Current为最新版) 安装步骤:默认下一步 查看版本: 命令 node -V 安装Hexo 在你的任意盘符下,创建一个文 件夹,在命令窗口通过cd命令到该目录 执行安装命令: npm i -g hexo 安装完成,查看版本 执行初始化命令: hexo init 生成如下文件 关于生成文件 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 Hexo常用命令:有些会经常用到 npm install hexo -g #安装 npm update hexo -g #更新 hexo init #初始化 hexo n &quot;name&quot; #新建文章 hexo g #生成静态网页 hexo p #发表草稿。 hexo s #启动服务 hexo d #部署网站 参数：-g 部署之前先生成静态文件。 npm install hexo-server --save #安装服务 hexo s #启动服务 hexo server -p 5000 #更改端口 hexo s -s #静态模式 hexo s -i 192.168.1.1 #自定义ip hexo clean #清除缓存 hexo d -g #部署 hexo g -d 在Git Bash **输入命令 hexo s** 启动本地预览,默认端口号是4000 在浏览器中输入 localhost:4000,打开本地预览,初始化效果图: NexT主题第一步的初始化工作部分已经完成!接下来,开始第二部Hexo上面有很多主题可供选择,但是NexT主题在Github上面Star最高!本文已NexT主题为例,进行主题建设.当然这一部分比较繁琐,想要搭建出自己喜欢的效果,还是要多下些功夫 安装NexT主题 在你创建的文件夹下,右键调用 Git Bash,我的文件夹叫MyBlog 下载最新版主题:输入命令: git clone https://github.com/iissnan/hexo-theme-next themes/next 可以浏览官方文档: http://theme-next.iissnan.com/ 下载稳定版和进行其他相应操作,一下配置内容仅供大家参考,大部分内容来自官方文档,如果需要可以自行浏览官方文档 安装成功 启用NexT主题关于配置文件 我的站点配置文件 对应的themes下next下的就是主题配置文件 启用主题 本地预览Next主题窗口终端中输入hexo s启动服务 浏览器输入 localhost:4000 是时候可能会发生端口占用的情况,上面常用命令中有修改端口号的方法 主题设定 关于主题设置 个人推荐参照官方文档,一下内容多为图片无法CopyNexT默认提供了四种,就是两种导航栏在侧栏,两种导航栏在顶部!依据个人喜好设定: 设置语言 值得注意的是在站点和主题配置文件下!输入中文乱码的请问题可以通过一下方式解决:打开文件时选择文件输出格式,编辑器中保存即可! 也有人说,通过txt打开另存为的方式,也可以设置!没试过,我有最优方案,没必要试用其他的. 设置导航栏菜单里面的页面可以根据个人需求进行模仿添加!不过需要在NexT主题目录下的 languages/{language}.yml进行添加才能显示你所需要的Language 新建页面 新建页面代码如下:新建的页面都存在的站点目录下Source文件夹中 设置代码高亮 设置侧栏设置侧栏,如图可以根据你的需求进行显示! 设置头像 设置侧边社交链接 开启友情链接 关注微信公众号 开启打赏功能 公益 背景动画官方文档估计是跟不上更新了,我用的最新的背景动画有四种 设置阅读全文 更改字体 文章显示 摘录 文章宽度 编写文章方式文章默认存放在站点目录下的source/posts中comments:false 表示关闭第三方评论服务;注意空格 集成第三方服务在追求完美的道路上,我们永不止步 百度统计注册百度统计,获取百度统计ID 不蒜子统计 本地搜索 开启字数统计,阅读时长你还可以根据hexo内置标签进行一下个性化操作!不过我觉得没必要了,毕竟这个只是工具拿来用了,效果还可以就行了!没必要搞的花费太多时间深入研究!毕竟人家Hexo就是要你用的时候能够简单高效! Github关于GithubgitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。2018年6月4日，微软宣布，通过75亿美元的股票交易收购代码托管平台GitHub。 Github注册 点击登录 点击注册 新建仓库 注意:新建仓库名必须是 yourName(你的用户名).github.io yourName即你github用户名. 仓库建造完成之后开启下一步 配置SSH key在git Bash输入: 如果提示：No such file or directory 说明你是第一次使用git 测试是否成功 在站点配置文件最后添加你的仓库地址! 保存! 最后部署本地站点到github在生成以及部署之前，需要安装一个扩展： npm install hexo-deployer-git --save 清除生成的静态网页缓存数据 生成文章对应的静态页面 hexo g 部署本地站点到github命令 hexo deploy 中文乱码之解决方案: 使用自己编辑器打开或者保存的时候选择UTF-8格式即可解决我用的编辑器UltraEdit 没有编辑器使用txt给是的记事本打开也能更改 点击查看MyBlog我的博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
